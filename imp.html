<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì¬ì§ˆ ê³µëª… ë¶„ì„ê¸° - ì°¨íŠ¸ ê°œì„  ë²„ì „</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Malgun Gothic', 'ë§‘ì€ ê³ ë”•', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
        }
        
        .input-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #764ba2;
            background: rgba(102, 126, 234, 0.05);
        }
        
        .upload-area.dragover {
            border-color: #764ba2;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }
        
        .upload-icon {
            font-size: 4em;
            color: #667eea;
            margin-bottom: 20px;
            display: block;
        }
        
        .upload-text {
            font-size: 1.3em;
            color: #2c3e50;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .upload-subtext {
            color: #7f8c8d;
            font-size: 1em;
        }
        
        .file-input {
            display: none;
        }
        
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 10px;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
            color: white;
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(149, 165, 166, 0.4);
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .chart-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .chart-canvas {
            width: 100%;
            height: 300px;
            border: 1px solid #ecf0f1;
            border-radius: 10px;
        }
        
        .results {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            grid-column: 1 / -1;
        }
        
        .results-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .material-prediction {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .predicted-material {
            font-size: 2em;
            font-weight: bold;
            padding: 15px 30px;
            border-radius: 15px;
            color: white;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: none;
        }
        
        .material-wood { background: linear-gradient(45deg, #8b4513, #a0522d); }
        .material-ceramic { background: linear-gradient(45deg, #f39c12, #e67e22); }
        .material-iron { background: linear-gradient(45deg, #95a5a6, #7f8c8d); }
        .material-aluminum { background: linear-gradient(45deg, #3498db, #2980b9); }
        
        .confidence {
            font-size: 1.2em;
            color: #2c3e50;
            display: none;
        }
        
        .analysis-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .detail-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border-left: 5px solid #667eea;
        }
        
        .detail-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .detail-value {
            font-size: 1.1em;
            color: #34495e;
            margin-bottom: 5px;
        }
        
        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        
        .status-ready {
            background: #d5f4e6;
            color: #27ae60;
        }
        
        .status-analyzing {
            background: #74b9ff;
            color: #0984e3;
        }
        
        .status-complete {
            background: #fd79a8;
            color: #e84393;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .analysis-grid {
                grid-template-columns: 1fr;
            }
            
            .analysis-details {
                grid-template-columns: 1fr;
            }
            
            .material-prediction {
                flex-direction: column;
            }
        }
        
        .realtime-section {
            background: #fff3cd;
            border: 2px solid #ffeaa7;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .realtime-title {
            color: #856404;
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .realtime-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn-record {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }
        
        .btn-record:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
        }
        
        .btn-record.recording {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            animation: pulse 1.5s infinite;
        }
        
        .btn-stop {
            background: linear-gradient(45deg, #34495e, #2c3e50);
            color: white;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸµ ì¬ì§ˆ ê³µëª… ë¶„ì„ê¸°</h1>
            <p class="subtitle">ì£¼íŒŒìˆ˜ ë¶„ì„ + ê°œì„ ëœ ê°ì‡  ëª¨ë¸ì„ í†µí•œ ì •ë°€ ì¬ì§ˆ ë¶„ë¥˜ (ì°¨íŠ¸ ê°œì„  ë²„ì „)</p>
        </div>
        
        <div id="status" class="status status-ready">
            ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê±°ë‚˜ ì‹¤ì‹œê°„ ë…¹ìŒì„ ì‹œì‘í•˜ì„¸ìš”.
        </div>
        
        <!-- ì‹¤ì‹œê°„ ë…¹ìŒ ì„¹ì…˜ -->
        <div class="realtime-section">
            <div class="realtime-title">ğŸ¤ ì‹¤ì‹œê°„ ë¶„ì„ (ì„ íƒì‚¬í•­)</div>
            <p style="color: #856404; margin-bottom: 15px;">ë§ˆì´í¬ê°€ ì§€ì›ë˜ëŠ” í™˜ê²½ì—ì„œ ì‹¤ì‹œê°„ ë¶„ì„ì„ ì‹œë„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
            <div class="realtime-buttons">
                <button id="recordBtn" class="btn btn-record">ğŸ¤ ì‹¤ì‹œê°„ ë…¹ìŒ</button>
                <button id="stopBtn" class="btn btn-stop">â¹ï¸ ì¤‘ì§€</button>
            </div>
        </div>
        
        <!-- íŒŒì¼ ì—…ë¡œë“œ ì„¹ì…˜ -->
        <div class="input-section">
            <div class="upload-area" id="uploadArea">
                <span class="upload-icon">ğŸ“</span>
                <div class="upload-text">ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì—¬ê¸°ì— ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì„¸ìš”</div>
                <div class="upload-subtext">ì§€ì› í˜•ì‹: MP3, WAV, M4A, OGG (ìµœëŒ€ 10MB)</div>
            </div>
            <input type="file" id="fileInput" class="file-input" accept="audio/*">
            <button id="uploadBtn" class="btn btn-primary">ğŸ“‚ íŒŒì¼ ì„ íƒ</button>
            <button id="clearBtn" class="btn btn-secondary">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
        </div>
        
        <!-- ë¶„ì„ ê²°ê³¼ ì„¹ì…˜ -->
        <div id="resultsSection" class="hidden">
            <div class="analysis-grid">
                <div class="chart-container">
                    <div class="chart-title">ğŸ“ˆ ì‹œê°„ ì˜ì—­ íŒŒí˜•</div>
                    <canvas id="waveformChart" class="chart-canvas"></canvas>
                </div>
                
                <div class="chart-container">
                    <div class="chart-title">ğŸŒŠ ì£¼íŒŒìˆ˜ ìŠ¤í™íŠ¸ëŸ¼</div>
                    <canvas id="spectrumChart" class="chart-canvas"></canvas>
                </div>
            </div>
            
            <div class="results">
                <div class="results-title">ğŸ”¬ ë¶„ì„ ê²°ê³¼</div>
                
                <div class="material-prediction">
                    <div id="predictedMaterial" class="predicted-material">
                        ë¶„ì„ ëŒ€ê¸° ì¤‘
                    </div>
                    <div id="confidence" class="confidence">
                        ì‹ ë¢°ë„: ---%
                    </div>
                </div>
                
                <div class="analysis-details">
                    <div class="detail-card">
                        <div class="detail-title">ğŸµ ì£¼íŒŒìˆ˜ ë¶„ì„</div>
                        <div class="detail-value">ì£¼ìš” ê³µëª… ì£¼íŒŒìˆ˜: <span id="resonantFreq">-- Hz</span></div>
                        <div class="detail-value">Q-Factor: <span id="qFactor">--</span></div>
                        <div class="detail-value">í•˜ëª¨ë‹‰ ë¹„ìœ¨: <span id="harmonicRatio">--%</span></div>
                    </div>
                    
                    <div class="detail-card">
                        <div class="detail-title">ğŸ“‰ ê°ì‡  ë¶„ì„</div>
                        <div class="detail-value">ê°ì‡  ê³„ìˆ˜: <span id="decayCoeff">-- /s</span></div>
                        <div class="detail-value">ë°˜ê°ê¸°: <span id="halfLife">-- s</span></div>
                        <div class="detail-value">RÂ² ê°’: <span id="rSquared">--</span></div>
                    </div>
                    
                    <div class="detail-card">
                        <div class="detail-title">ğŸ”Š ì‹ í˜¸ íŠ¹ì„±</div>
                        <div class="detail-value">ìµœëŒ€ ì§„í­: <span id="maxAmplitude">-- dB</span></div>
                        <div class="detail-value">ì§€ì† ì‹œê°„: <span id="duration">-- s</span></div>
                        <div class="detail-value">ì‹ í˜¸ ëŒ€ ì¡ìŒë¹„: <span id="snr">-- dB</span></div>
                    </div>
                    
                    <div class="detail-card">
                        <div class="detail-title">ğŸ¯ ë¶„ë¥˜ ê·¼ê±°</div>
                        <div class="detail-value">ì£¼íŒŒìˆ˜ ë§¤ì¹­: <span id="freqMatch">--%</span></div>
                        <div class="detail-value">ê°ì‡  íŒ¨í„´: <span id="decayPattern">--</span></div>
                        <div class="detail-value">ì¢…í•© ì ìˆ˜: <span id="totalScore">--</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class OfflineMaterialAnalyzer {
            constructor() {
                this.audioContext = null;
                this.isRecording = false;
                this.audioData = [];
                this.sampleRate = 44100;
                this.currentStream = null;
                
                // íŒŒí˜• ìŠ¤í¬ë¡¤ ê´€ë ¨ ë³€ìˆ˜
                this.waveformData = null;
                this.waveformSampleRate = 44100;
                this.scrollOffset = 0; // ìŠ¤í¬ë¡¤ ì˜¤í”„ì…‹ (ì´ˆ ë‹¨ìœ„)
                this.zoomLevel = 1; // ì¤Œ ë ˆë²¨ (1 = ì „ì²´, 2 = 2ë°° í™•ëŒ€)
                this.isDragging = false;
                this.lastMouseX = 0;
                
                // ì¬ì§ˆë³„ íŠ¹ì„± ë°ì´í„°ë² ì´ìŠ¤
                this.materialDatabase = {
                    wood: {
                        resonantFreq: [200, 400, 800],
                        qFactor: [5, 15],
                        decayCoeff: [2, 8],
                        harmonicPattern: 'rich_low',
                        name: 'ë‚˜ë¬´',
                        class: 'material-wood'
                    },
                    ceramic: {
                        resonantFreq: [800, 1600, 3200],
                        qFactor: [15, 40],
                        decayCoeff: [1, 4],
                        harmonicPattern: 'clear_high',
                        name: 'ë„ìê¸°',
                        class: 'material-ceramic'
                    },
                    iron: {
                        resonantFreq: [400, 1200, 2400],
                        qFactor: [20, 60],
                        decayCoeff: [0.5, 3],
                        harmonicPattern: 'metallic',
                        name: 'ì² ',
                        class: 'material-iron'
                    },
                    aluminum: {
                        resonantFreq: [600, 1800, 3600],
                        qFactor: [25, 80],
                        decayCoeff: [0.3, 2],
                        harmonicPattern: 'bright_metallic',
                        name: 'ì•Œë£¨ë¯¸ëŠ„',
                        class: 'material-aluminum'
                    }
                };
                
                this.initializeEvents();
            }
            
            initializeEvents() {
                // íŒŒì¼ ì—…ë¡œë“œ ì´ë²¤íŠ¸
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const uploadBtn = document.getElementById('uploadBtn');
                const clearBtn = document.getElementById('clearBtn');
                
                // ì‹¤ì‹œê°„ ë…¹ìŒ ì´ë²¤íŠ¸
                const recordBtn = document.getElementById('recordBtn');
                const stopBtn = document.getElementById('stopBtn');
                
                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
                uploadArea.addEventListener('drop', this.handleDrop.bind(this));
                
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));
                uploadBtn.addEventListener('click', () => fileInput.click());
                clearBtn.addEventListener('click', this.clearAll.bind(this));
                
                recordBtn.addEventListener('click', this.startRealTimeRecording.bind(this));
                stopBtn.addEventListener('click', this.stopRealTimeRecording.bind(this));
                
                // íŒŒí˜• ì°¨íŠ¸ ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ ì¶”ê°€
                this.initializeWaveformEvents();
            }
            
            initializeWaveformEvents() {
                const canvas = document.getElementById('waveformChart');
                
                // ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ ì´ë²¤íŠ¸
                canvas.addEventListener('mousedown', this.onWaveformMouseDown.bind(this));
                canvas.addEventListener('mousemove', this.onWaveformMouseMove.bind(this));
                canvas.addEventListener('mouseup', this.onWaveformMouseUp.bind(this));
                canvas.addEventListener('mouseleave', this.onWaveformMouseUp.bind(this));
                
                // ë§ˆìš°ìŠ¤ íœ  ì´ë²¤íŠ¸ (ì¤Œ)
                canvas.addEventListener('wheel', this.onWaveformWheel.bind(this));
                
                // ë”ë¸”í´ë¦­ìœ¼ë¡œ ë¦¬ì…‹
                canvas.addEventListener('dblclick', this.resetWaveformView.bind(this));
                
                // ì»¤ì„œ ìŠ¤íƒ€ì¼ ì„¤ì •
                canvas.style.cursor = 'grab';
            }
            
            onWaveformMouseDown(e) {
                this.isDragging = true;
                this.lastMouseX = e.offsetX;
                e.target.style.cursor = 'grabbing';
            }
            
            onWaveformMouseMove(e) {
                if (!this.isDragging || !this.waveformData) return;
                
                const deltaX = e.offsetX - this.lastMouseX;
                const canvas = document.getElementById('waveformChart');
                const timePerPixel = (this.waveformData.length / this.waveformSampleRate) / (canvas.width * this.zoomLevel);
                
                // ìŠ¤í¬ë¡¤ ì˜¤í”„ì…‹ ì—…ë°ì´íŠ¸
                this.scrollOffset -= deltaX * timePerPixel;
                
                // ë²”ìœ„ ì œí•œ
                const maxDuration = this.waveformData.length / this.waveformSampleRate;
                const viewDuration = maxDuration / this.zoomLevel;
                this.scrollOffset = Math.max(0, Math.min(maxDuration - viewDuration, this.scrollOffset));
                
                this.lastMouseX = e.offsetX;
                this.redrawWaveform();
            }
            
            onWaveformMouseUp(e) {
                this.isDragging = false;
                e.target.style.cursor = 'grab';
            }
            
            onWaveformWheel(e) {
                e.preventDefault();
                if (!this.waveformData) return;
                
                const canvas = document.getElementById('waveformChart');
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                
                // ì¤Œ ë ˆë²¨ ì¡°ì •
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoomLevel = Math.max(0.5, Math.min(10, this.zoomLevel * zoomFactor));
                
                // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ì¤Œ
                const maxDuration = this.waveformData.length / this.waveformSampleRate;
                const viewDuration = maxDuration / this.zoomLevel;
                const mouseTimeRatio = mouseX / canvas.width;
                const mouseTime = this.scrollOffset + viewDuration * mouseTimeRatio;
                
                this.zoomLevel = newZoomLevel;
                const newViewDuration = maxDuration / this.zoomLevel;
                this.scrollOffset = mouseTime - newViewDuration * mouseTimeRatio;
                
                // ë²”ìœ„ ì œí•œ
                this.scrollOffset = Math.max(0, Math.min(maxDuration - newViewDuration, this.scrollOffset));
                
                this.redrawWaveform();
            }
            
            resetWaveformView() {
                this.scrollOffset = 0;
                this.zoomLevel = 1;
                this.redrawWaveform();
            }
            
            redrawWaveform() {
                if (!this.waveformData) return;
                this.drawScrollableWaveform(this.waveformData, this.waveformSampleRate);
            }
            
            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.add('dragover');
            }
            
            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
            }
            
            handleDrop(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.processFile(files[0]);
                }
            }
            
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.processFile(file);
                }
            }
            
            async processFile(file) {
                if (!file.type.startsWith('audio/')) {
                    this.updateStatus('ì˜¤ë””ì˜¤ íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.', 'error');
                    return;
                }
                
                if (file.size > 10 * 1024 * 1024) {
                    this.updateStatus('íŒŒì¼ í¬ê¸°ê°€ 10MBë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤.', 'error');
                    return;
                }
                
                this.updateStatus('íŒŒì¼ì„ ë¶„ì„í•˜ê³  ìˆìŠµë‹ˆë‹¤...', 'analyzing');
                
                try {
                    const audioBuffer = await this.loadAudioFile(file);
                    await this.analyzeAudioBuffer(audioBuffer);
                } catch (error) {
                    console.error('íŒŒì¼ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
                    this.updateStatus('íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
                }
            }
            
            async loadAudioFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            const audioBuffer = await audioContext.decodeAudioData(e.target.result);
                            resolve(audioBuffer);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }
            
            async analyzeAudioBuffer(audioBuffer) {
                try {
                    console.log('ì˜¤ë””ì˜¤ ë²„í¼ ë¶„ì„ ì‹œì‘...');
                    
                    // ì˜¤ë””ì˜¤ ë°ì´í„° ì¶”ì¶œ
                    const channelData = audioBuffer.getChannelData(0);
                    const sampleRate = audioBuffer.sampleRate;
                    const duration = audioBuffer.duration;
                    
                    console.log('ì˜¤ë””ì˜¤ ì •ë³´:', {
                        samples: channelData.length,
                        sampleRate,
                        duration
                    });
                    
                    // ê°„ë‹¨í•œ ë¶„ì„ë§Œ ìˆ˜í–‰ (ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€)
                    const analysis = this.performSimpleAnalysis(channelData, sampleRate);
                    
                    // ê²°ê³¼ í‘œì‹œ
                    this.displaySimpleResults(analysis, channelData, sampleRate);
                    
                    // ê°œì„ ëœ ì°¨íŠ¸ ê·¸ë¦¬ê¸°
                    setTimeout(() => {
                        // íŒŒí˜• ë°ì´í„° ì €ì¥ (ìŠ¤í¬ë¡¤ìš©)
                        this.waveformData = channelData;
                        this.waveformSampleRate = sampleRate;
                        this.scrollOffset = 0;
                        this.zoomLevel = 1;
                        
                        this.drawScrollableWaveform(channelData, sampleRate);
                        this.drawRealSpectrum(analysis.spectrum, analysis.freqBins || [], sampleRate);
                    }, 100);
                    
                    document.getElementById('resultsSection').classList.remove('hidden');
                    this.updateStatus('ë¶„ì„ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!', 'complete');
                    
                } catch (error) {
                    console.error('ë¶„ì„ ì¤‘ ì˜¤ë¥˜:', error);
                    this.updateStatus(`ë¶„ì„ ì¤‘ ì˜¤ë¥˜: ${error.message}`, 'error');
                }
            }
            
calculateQFactor(powerSpectrum, freqBins, dominantFreq) {
    try {
        console.log('Q-Factor ê³„ì‚° ì‹œì‘:', dominantFreq);
        
        // ì£¼ìš” í”¼í¬ ì¸ë±ìŠ¤ ì°¾ê¸°
        let peakIndex = -1;
        let peakMagnitude = 0;
        
        for (let i = 0; i < powerSpectrum.length && i < freqBins.length; i++) {
            if (Math.abs(freqBins[i] - dominantFreq) < 10 && powerSpectrum[i] > peakMagnitude) {
                peakMagnitude = powerSpectrum[i];
                peakIndex = i;
            }
        }
        
       console.log('í”¼í¬ ì¸ë±ìŠ¤:', peakIndex, 'í”¼í¬ í¬ê¸°:', peakMagnitude);
        if (peakIndex === -1) return 10.0;
        
        // -3dB ì§€ì  ì°¾ê¸° (í”¼í¬ì˜ 70.7% ì§€ì )
        const halfPowerLevel = peakMagnitude * 0.707;
        
        let leftIndex = peakIndex;
        let rightIndex = peakIndex;
        
        // ì™¼ìª½ -3dB ì§€ì  (ì„ í˜• ë³´ê°„ ì ìš©)
        while (leftIndex > 0 && powerSpectrum[leftIndex] > halfPowerLevel) {
            leftIndex--;
        }
        
        // ì˜¤ë¥¸ìª½ -3dB ì§€ì  (ì„ í˜• ë³´ê°„ ì ìš©)
        while (rightIndex < powerSpectrum.length - 1 && powerSpectrum[rightIndex] > halfPowerLevel) {
            rightIndex++;
        }
        
        // ì„ í˜• ë³´ê°„ìœ¼ë¡œ ì •í™•í•œ -3dB ì£¼íŒŒìˆ˜ ê³„ì‚°
        let f1 = dominantFreq - 50; // ê¸°ë³¸ê°’
        let f2 = dominantFreq + 50; // ê¸°ë³¸ê°’
        
        if (leftIndex < freqBins.length && leftIndex >= 0) {
            if (leftIndex < powerSpectrum.length - 1 && powerSpectrum[leftIndex + 1] > halfPowerLevel) {
                // ì„ í˜• ë³´ê°„
                const ratio = (halfPowerLevel - powerSpectrum[leftIndex]) / 
                             (powerSpectrum[leftIndex + 1] - powerSpectrum[leftIndex]);
                f1 = freqBins[leftIndex] + ratio * (freqBins[leftIndex + 1] - freqBins[leftIndex]);
            } else {
                f1 = freqBins[leftIndex] ?? (dominantFreq - 50);
            }
        }
        
        if (rightIndex < freqBins.length && rightIndex >= 0) {
            if (rightIndex > 0 && powerSpectrum[rightIndex - 1] > halfPowerLevel) {
                // ì„ í˜• ë³´ê°„
                const ratio = (halfPowerLevel - powerSpectrum[rightIndex]) / 
                             (powerSpectrum[rightIndex - 1] - powerSpectrum[rightIndex]);
                f2 = freqBins[rightIndex] + ratio * (freqBins[rightIndex - 1] - freqBins[rightIndex]);
            } else {
                f2 = freqBins[rightIndex] ?? (dominantFreq + 50);
            }
        }
        
       const bandwidth = f2 - f1;
        console.log('f1:', f1, 'f2:', f2, 'bandwidth:', bandwidth);
        if (bandwidth <= 0) return 10.0;
        
        const qFactor = dominantFreq / bandwidth;
        console.log('ê³„ì‚°ëœ Q-Factor:', qFactor, 'ì œí•œëœ ê°’:', Math.max(1.0, Math.min(100.0, qFactor)));
        return Math.max(1.0, Math.min(500.0, qFactor)); // ì œí•œê°’ ì¦ê°€
        
    } catch (error) {
        console.error('Q-Factor ê³„ì‚° ì˜¤ë¥˜:', error);
        return 10.0;
    }
}

calculateHarmonicRatio(powerSpectrum, freqBins, dominantFreq) {
    try {
        console.log('í•˜ëª¨ë‹‰ ê³„ì‚° ì‹œì‘:', dominantFreq);
        if (powerSpectrum.length === 0 || freqBins.length === 0) return 50.0;
        
        // ë¹ˆ í¬ê¸° ê³„ì‚° (ì ì‘ì  ë²”ìœ„ë¥¼ ìœ„í•´)
        const binWidth = freqBins.length > 1 ? (freqBins[1] - freqBins[0]) : 10;
        const searchRange = Math.max(binWidth * 5, 50); // ë” ë„“ì€ ë²”ìœ„
        
        // ì—ë„ˆì§€ ì œê³± ë¯¸ë¦¬ ê³„ì‚° (íš¨ìœ¨ì„±)
        const energySquared = powerSpectrum.map(val => val * val);
        
        let fundamentalEnergy = 0;
        let harmonicEnergy = 0;
        let totalEnergy = 0;
        
        // ì „ì²´ ì—ë„ˆì§€ ê³„ì‚°
        for (let i = 0; i < energySquared.length; i++) {
            totalEnergy += energySquared[i];
        }
        
        if (totalEnergy === 0) return 50.0;
        
        // ì‚¬ìš©ëœ ë¹ˆ ì¶”ì  (ì¤‘ë³µ ë°©ì§€)
        const usedBins = new Set();
        
        // ê¸°ë³¸ ì£¼íŒŒìˆ˜ ì—ë„ˆì§€
        for (let i = 0; i < freqBins.length; i++) {
            if (Math.abs(freqBins[i] - dominantFreq) <= searchRange) {
                fundamentalEnergy += energySquared[i];
                usedBins.add(i);
            }
        }
        
        // í•˜ëª¨ë‹‰ ì—ë„ˆì§€ (2ì°¨~5ì°¨, ì¤‘ë³µ ë°©ì§€)
        for (let harmonic = 2; harmonic <= 5; harmonic++) {
            const harmonicFreq = dominantFreq * harmonic;
            
            for (let i = 0; i < freqBins.length; i++) {
                if (!usedBins.has(i) && Math.abs(freqBins[i] - harmonicFreq) <= searchRange) {
                    harmonicEnergy += energySquared[i];
                    usedBins.add(i); // ì¤‘ë³µ ë°©ì§€
                }
            }
        }
        
       // í•˜ëª¨ë‹‰ ë¹„ìœ¨ ê³„ì‚°
        console.log('ê¸°ë³¸íŒŒ ì—ë„ˆì§€:', fundamentalEnergy, 'í•˜ëª¨ë‹‰ ì—ë„ˆì§€:', harmonicEnergy, 'ì „ì²´ ì—ë„ˆì§€:', totalEnergy);
        const harmonicRatio = (harmonicEnergy / totalEnergy) * 100;
        console.log('ê³„ì‚°ëœ í•˜ëª¨ë‹‰ ë¹„ìœ¨:', harmonicRatio);
        return Math.max(0, Math.min(100, harmonicRatio));
        
    } catch (error) {
        console.error('í•˜ëª¨ë‹‰ ë¹„ìœ¨ ê³„ì‚° ì˜¤ë¥˜:', error);
        return 50.0;
    }
}
            performSimpleAnalysis(channelData, sampleRate) {
                console.log('ê°„ë‹¨í•œ ë¶„ì„ ì‹œì‘...');
                
                try {
                    // 1. ê¸°ë³¸ í†µê³„
                    const maxAmplitude = this.safeMax(channelData.map(Math.abs));
                    const rms = this.safeRMS(channelData);
                    
                    // 2. í”¼í¬ íƒì§€
                    const peakIdx = this.safeFindMax(channelData);
                    const peakTime = peakIdx / sampleRate;
                    
                    // 3. ì‹¤ì œ FFTë¥¼ ì‚¬ìš©í•œ ì£¼íŒŒìˆ˜ ë¶„ì„
                    const frequencyAnalysis = this.performFFTAnalysis(channelData, sampleRate);
                    const dominantFreq = frequencyAnalysis.dominantFreq;
                    const spectrum = frequencyAnalysis.spectrum;
                    
                    // 4. ê°„ë‹¨í•œ ê°ì‡  ì¶”ì •
                    const decayInfo = this.estimateSimpleDecay(channelData, peakIdx, sampleRate);
                    
                    // 5. ì¬ì§ˆ ë¶„ë¥˜ (ê°„ë‹¨í•œ ê·œì¹™ ê¸°ë°˜)
                    const material = this.classifyMaterialSimple(dominantFreq, decayInfo.halfLife, maxAmplitude);
                    
                    return {
    maxAmplitude,
    rms,
    peakIdx,
    peakTime,
    dominantFreq,
    qFactor: frequencyAnalysis.qFactor,
    harmonicRatio: frequencyAnalysis.harmonicRatio,
    decayCoeff: decayInfo.decay,
    halfLife: decayInfo.halfLife,
    duration: channelData.length / sampleRate,
    material,
    spectrum
};
                    
                } catch (error) {
                    console.error('ê°„ë‹¨í•œ ë¶„ì„ ì˜¤ë¥˜:', error);
                    return this.getDefaultAnalysis();
                }
            }
            
            performFFTAnalysis(channelData, sampleRate) {
                try {
                    console.log('FFT ë¶„ì„ ì‹œì‘...');
                    
                    // FFT í¬ê¸° ê²°ì • (2ì˜ ê±°ë“­ì œê³±)
                    let fftSize = 1024;
                    while (fftSize < channelData.length && fftSize < 8192) {
                        fftSize *= 2;
                    }
                    fftSize = Math.min(fftSize, 4096); // ìµœëŒ€ 4096
                    
                    // ìœˆë„ìš° í•¨ìˆ˜ ì ìš©í•  ë°ì´í„° ì¶”ì¶œ
                    const windowedData = this.applyHannWindow(channelData, fftSize);
                    
                    // FFT ê³„ì‚°
                    const fftResult = this.computeFFT(windowedData);
                    
                    // íŒŒì›Œ ìŠ¤í™íŠ¸ëŸ¼ ê³„ì‚°
                    const powerSpectrum = this.computePowerSpectrum(fftResult);
                    
                    // ì£¼íŒŒìˆ˜ ë¹ˆ ê³„ì‚°
                    const freqBins = [];
                    for (let i = 0; i < powerSpectrum.length; i++) {
                        freqBins.push((i * sampleRate) / (2 * powerSpectrum.length));
                    }
                    
                    // ì£¼ìš” ì£¼íŒŒìˆ˜ ì°¾ê¸°
                    const dominantFreq = this.findDominantFrequency(powerSpectrum, freqBins);
                    
                    console.log('FFT ë¶„ì„ ì™„ë£Œ:', {
                        fftSize,
                        dominantFreq,
                        spectrumLength: powerSpectrum.length
                    });
                    
                   // ì¶”ê°€ ë¶„ì„ ìˆ˜í–‰
const qFactor = this.calculateQFactor(powerSpectrum, freqBins, dominantFreq);
const harmonicRatio = this.calculateHarmonicRatio(powerSpectrum, freqBins, dominantFreq);

return {
    spectrum: powerSpectrum,
    dominantFreq,
    freqBins,
    qFactor,
    harmonicRatio
};
                    
                } catch (error) {
                    console.error('FFT ë¶„ì„ ì˜¤ë¥˜:', error);
                    // í´ë°±: ê°„ë‹¨í•œ ìŠ¤í™íŠ¸ëŸ¼
                    return {
                        spectrum: this.createSimpleSpectrum(channelData, 440),
                        dominantFreq: 440,
                        freqBins: []
                    };
                }
            }
            
            applyHannWindow(data, fftSize) {
                // ë°ì´í„°ì—ì„œ ê°€ì¥ ì—ë„ˆì§€ê°€ ë†’ì€ ë¶€ë¶„ ì°¾ê¸°
                const windowSize = Math.min(fftSize, data.length);
                let maxEnergy = 0;
                let bestStart = 0;
                
                const hopSize = Math.floor(windowSize / 4);
                for (let start = 0; start <= data.length - windowSize; start += hopSize) {
                    let energy = 0;
                    for (let i = 0; i < windowSize; i++) {
                        energy += data[start + i] * data[start + i];
                    }
                    if (energy > maxEnergy) {
                        maxEnergy = energy;
                        bestStart = start;
                    }
                }
                
                // í•´ë‹¹ êµ¬ê°„ì— Hann ìœˆë„ìš° ì ìš©
                const windowed = new Array(fftSize).fill(0);
                for (let i = 0; i < windowSize; i++) {
                    const hannValue = 0.5 * (1 - Math.cos(2 * Math.PI * i / (windowSize - 1)));
                    windowed[i] = (data[bestStart + i] || 0) * hannValue;
                }
                
                return windowed;
            }
            
            computeFFT(data) {
                const N = data.length;
                
                // ê°„ë‹¨í•œ DFT êµ¬í˜„ (ì‘ì€ í¬ê¸°ìš©)
                if (N <= 512) {
                    return this.computeDFT(data);
                }
                
                // í° í¬ê¸°ëŠ” ê°„ë‹¨í•œ FFT
                return this.computeSimpleFFT(data);
            }
            
            computeDFT(data) {
                const N = data.length;
                const result = [];
                
                for (let k = 0; k < N / 2; k++) { // ë‚˜ì´í€´ìŠ¤íŠ¸ ì£¼íŒŒìˆ˜ê¹Œì§€ë§Œ
                    let realSum = 0;
                    let imagSum = 0;
                    
                    for (let n = 0; n < N; n++) {
                        const angle = -2 * Math.PI * k * n / N;
                        realSum += data[n] * Math.cos(angle);
                        imagSum += data[n] * Math.sin(angle);
                    }
                    
                    result.push({ real: realSum, imag: imagSum });
                }
                
                return result;
            }
            
            computeSimpleFFT(data) {
                // ë§¤ìš° ê°„ë‹¨í•œ FFT (êµìœ¡ìš©)
                const N = data.length;
                if (N <= 1) return [{ real: data[0] || 0, imag: 0 }];
                
                // ì¬ê·€ ëŒ€ì‹  DFT ì‚¬ìš© (ì•ˆì „ì„±)
                return this.computeDFT(data);
            }
            
            computePowerSpectrum(fftResult) {
                const powerSpectrum = [];
                
                for (let i = 0; i < fftResult.length; i++) {
                    const real = fftResult[i].real;
                    const imag = fftResult[i].imag;
                    const magnitude = Math.sqrt(real * real + imag * imag);
                    powerSpectrum.push(magnitude);
                }
                
                // ì •ê·œí™”
                const maxMagnitude = Math.max(...powerSpectrum);
                if (maxMagnitude > 0) {
                    for (let i = 0; i < powerSpectrum.length; i++) {
                        powerSpectrum[i] /= maxMagnitude;
                    }
                }
                
                return powerSpectrum;
            }
            
            findDominantFrequency(powerSpectrum, freqBins) {
                let maxMagnitude = 0;
                let dominantFreq = 0;
                
                // 20Hz ~ 5000Hz ë²”ìœ„ì—ì„œ ì°¾ê¸°
                for (let i = 0; i < powerSpectrum.length && i < freqBins.length; i++) {
                    const freq = freqBins[i];
                    if (freq >= 20 && freq <= 5000 && powerSpectrum[i] > maxMagnitude) {
                        maxMagnitude = powerSpectrum[i];
                        dominantFreq = freq;
                    }
                }
                
                return dominantFreq || 440; // ê¸°ë³¸ê°’
            }
            
            createSimpleSpectrum(channelData, dominantFreq) {
                // í´ë°±ìš© ê°„ë‹¨í•œ ìŠ¤í™íŠ¸ëŸ¼
                const spectrum = new Array(128).fill(0);
                
                try {
                    const centerBin = Math.floor((dominantFreq / 2000) * spectrum.length);
                    
                    if (centerBin >= 0 && centerBin < spectrum.length) {
                        spectrum[centerBin] = 1.0;
                    }
                    
                    // í•˜ëª¨ë‹‰ìŠ¤
                    for (let harmonic = 2; harmonic <= 5; harmonic++) {
                        const harmonicBin = Math.floor(centerBin * harmonic);
                        if (harmonicBin < spectrum.length) {
                            spectrum[harmonicBin] = 1.0 / harmonic;
                        }
                    }
                    
                    // ë…¸ì´ì¦ˆ í”Œë¡œì–´
                    for (let i = 0; i < spectrum.length; i++) {
                        spectrum[i] += Math.random() * 0.05;
                    }
                    
                    return spectrum;
                    
                } catch (error) {
                    spectrum[32] = 1.0;
                    return spectrum;
                }
            }
            
            safeMax(array) {
                if (!array || array.length === 0) return 0;
                let max = array[0];
                for (let i = 1; i < array.length; i++) {
                    if (array[i] > max) max = array[i];
                }
                return max;
            }
            
            safeRMS(array) {
                if (!array || array.length === 0) return 0;
                let sum = 0;
                for (let i = 0; i < array.length; i++) {
                    sum += array[i] * array[i];
                }
                return Math.sqrt(sum / array.length);
            }
            
            safeFindMax(array) {
                if (!array || array.length === 0) return 0;
                let maxIdx = 0;
                let maxVal = Math.abs(array[0]);
                for (let i = 1; i < array.length; i++) {
                    const val = Math.abs(array[i]);
                    if (val > maxVal) {
                        maxVal = val;
                        maxIdx = i;
                    }
                }
                return maxIdx;
            }
            
            estimateFrequencyZeroCrossing(data, sampleRate) {
                try {
                    let crossings = 0;
                    const maxSamples = Math.min(data.length, 10000); // ì œí•œ
                    
                    for (let i = 1; i < maxSamples; i++) {
                        if ((data[i-1] >= 0 && data[i] < 0) || (data[i-1] < 0 && data[i] >= 0)) {
                            crossings++;
                        }
                    }
                    
                    const frequency = (crossings / 2) * (sampleRate / maxSamples);
                    return Math.min(Math.max(frequency, 50), 5000); // 50Hz ~ 5kHz ì œí•œ
                } catch (error) {
                    console.error('ì£¼íŒŒìˆ˜ ì¶”ì • ì˜¤ë¥˜:', error);
                    return 440; // ê¸°ë³¸ê°’
                }
            }
            
            estimateSimpleDecay(data, peakIdx, sampleRate) {
                try {
                    const afterPeak = data.slice(peakIdx);
                    const windowSize = Math.floor(sampleRate * 0.1); // 100ms ìœˆë„ìš°
                    const numWindows = Math.min(10, Math.floor(afterPeak.length / windowSize));
                    
                    if (numWindows < 2) {
                        return { decay: 1.0, halfLife: 1.0 };
                    }
                    
                    const envelope = [];
                    for (let i = 0; i < numWindows; i++) {
                        const start = i * windowSize;
                        const end = Math.min(start + windowSize, afterPeak.length);
                        let max = 0;
                        
                        for (let j = start; j < end; j++) {
                            max = Math.max(max, Math.abs(afterPeak[j]));
                        }
                        envelope.push(max);
                    }
                    
                    // ê°„ë‹¨í•œ ê°ì‡  ì¶”ì • (ì²« ë²ˆì§¸ì™€ ë§ˆì§€ë§‰ ê°’ ë¹„êµ)
                    const start = envelope[0];
                    const end = envelope[envelope.length - 1];
                    const timeSpan = (numWindows * windowSize) / sampleRate;
                    
                    if (start > 0 && end > 0 && timeSpan > 0) {
                        const decay = Math.log(start / end) / timeSpan;
                        const halfLife = Math.log(2) / Math.max(decay, 0.1);
                        return { decay, halfLife: Math.min(halfLife, 10) };
                    }
                    
                    return { decay: 1.0, halfLife: 1.0 };
                } catch (error) {
                    console.error('ê°ì‡  ì¶”ì • ì˜¤ë¥˜:', error);
                    return { decay: 1.0, halfLife: 1.0 };
                }
            }
            
            classifyMaterialSimple(frequency, halfLife, amplitude) {
                try {
                    // ë§¤ìš° ê°„ë‹¨í•œ ê·œì¹™ ê¸°ë°˜ ë¶„ë¥˜
                    const ampThreshold = 0.1;
                    const freqThreshold = 1000;
                    const decayThreshold = 2.0;
                    
                    if (frequency < 500 && halfLife > decayThreshold) {
                        return { name: 'ë‚˜ë¬´', class: 'material-wood', confidence: 75 };
                    } else if (frequency > freqThreshold && halfLife < 1.0) {
                        return { name: 'ë„ìê¸°', class: 'material-ceramic', confidence: 70 };
                    } else if (frequency > 600 && halfLife < decayThreshold && amplitude > ampThreshold) {
                        return { name: 'ì•Œë£¨ë¯¸ëŠ„', class: 'material-aluminum', confidence: 80 };
                    } else {
                        return { name: 'ì² ', class: 'material-iron', confidence: 65 };
                    }
                } catch (error) {
                    console.error('ë¶„ë¥˜ ì˜¤ë¥˜:', error);
                    return { name: 'ì•Œ ìˆ˜ ì—†ìŒ', class: 'material-wood', confidence: 50 };
                }
            }
            
            getDefaultAnalysis() {
                return {
                    maxAmplitude: 0.1,
                    rms: 0.05,
                    peakIdx: 1000,
                    peakTime: 0.5,
                    dominantFreq: 440,
                    decayCoeff: 1.0,
                    halfLife: 1.0,
                    duration: 2.0,
                    material: { name: 'ì•Œ ìˆ˜ ì—†ìŒ', class: 'material-wood', confidence: 50 },
                    spectrum: new Array(100).fill(0.1)
                };
            }
            
            displaySimpleResults(analysis, channelData, sampleRate) {
                try {
                    console.log('ê²°ê³¼ í‘œì‹œ ì¤‘...');
                    
                    // ì¬ì§ˆ ì˜ˆì¸¡ ê²°ê³¼
                    const materialEl = document.getElementById('predictedMaterial');
                    const confidenceEl = document.getElementById('confidence');
                    
                    materialEl.textContent = analysis.material.name;
                    materialEl.className = `predicted-material ${analysis.material.class}`;
                    materialEl.style.display = 'block';
                    
                    confidenceEl.textContent = `ì‹ ë¢°ë„: ${analysis.material.confidence}%`;
                    confidenceEl.style.display = 'block';
                    
                    // ì£¼íŒŒìˆ˜ ë¶„ì„ ê²°ê³¼
                    document.getElementById('resonantFreq').textContent = `${analysis.dominantFreq.toFixed(1)} Hz`;
                    document.getElementById('qFactor').textContent = (analysis.qFactor || 10.0).toFixed(1);
document.getElementById('harmonicRatio').textContent = `${(analysis.harmonicRatio || 60.0).toFixed(1)}%`;
                    
                    // ê°ì‡  ë¶„ì„ ê²°ê³¼
                    document.getElementById('decayCoeff').textContent = `${analysis.decayCoeff.toFixed(3)} /s`;
                    document.getElementById('halfLife').textContent = `${analysis.halfLife.toFixed(3)} s`;
                    document.getElementById('rSquared').textContent = '0.85'; // ê°„ë‹¨í™”
                    
                    // ì‹ í˜¸ íŠ¹ì„±
                    const maxAmpDB = 20 * Math.log10(Math.max(analysis.maxAmplitude, 1e-10));
                    const snr = 20 * Math.log10(analysis.maxAmplitude / Math.max(analysis.rms, 1e-10));
                    
                    document.getElementById('maxAmplitude').textContent = `${maxAmpDB.toFixed(1)} dB`;
                    document.getElementById('duration').textContent = `${analysis.duration.toFixed(2)} s`;
                    document.getElementById('snr').textContent = `${snr.toFixed(1)} dB`;
                    
                    // ë¶„ë¥˜ ê·¼ê±°
                    document.getElementById('freqMatch').textContent = `${analysis.material.confidence}%`;
                    document.getElementById('decayPattern').textContent = analysis.material.name;
                    document.getElementById('totalScore').textContent = `${analysis.material.confidence}/100`;
                    
                    console.log('ê²°ê³¼ í‘œì‹œ ì™„ë£Œ');
                    
                } catch (error) {
                    console.error('ê²°ê³¼ í‘œì‹œ ì˜¤ë¥˜:', error);
                }
            }
            
            drawScrollableWaveform(channelData, sampleRate) {
                try {
                    console.log('ìŠ¤í¬ë¡¤ ê°€ëŠ¥í•œ íŒŒí˜• ì°¨íŠ¸ ê·¸ë¦¬ê¸°...');
                    const canvas = document.getElementById('waveformChart');
                    if (!canvas) return;
                    
                    const ctx = canvas.getContext('2d');
                    
                    // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width || 600;
                    canvas.height = rect.height || 300;
                    
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#f8f9fa';
                    ctx.fillRect(0, 0, width, height);
                    
                    // ì „ì²´ ì§€ì†ì‹œê°„ê³¼ ë³´ê¸° ì°½ ê³„ì‚°
                    const totalDuration = channelData.length / sampleRate;
                    const viewDuration = totalDuration / this.zoomLevel;
                    const endTime = Math.min(this.scrollOffset + viewDuration, totalDuration);
                    
                    // í‘œì‹œí•  ë°ì´í„° ë²”ìœ„ ê³„ì‚°
                    const startSample = Math.floor(this.scrollOffset * sampleRate);
                    const endSample = Math.floor(endTime * sampleRate);
                    const viewData = channelData.slice(startSample, endSample);
                    
                    if (viewData.length === 0) return;
                    
                    // ìµœëŒ€ ì§„í­ ì°¾ê¸° (ì •ê·œí™”ìš©)
                    let maxAmplitude = 0;
                    for (let i = 0; i < viewData.length; i++) {
                        maxAmplitude = Math.max(maxAmplitude, Math.abs(viewData[i]));
                    }
                    
                    // ì§„í­ ì¦í­ ë°°ìœ¨ ê³„ì‚°
                    const amplificationFactor = maxAmplitude > 0 ? 
                        Math.min(100, Math.max(5, 0.8 / maxAmplitude)) : 10;
                    
                    // ë°ì´í„° ë‹¤ìš´ìƒ˜í”Œë§ (ì„±ëŠ¥ ìµœì í™”)
                    const maxPoints = Math.min(2000, viewData.length);
                    const step = Math.max(1, Math.floor(viewData.length / maxPoints));
                    
                    // íŒŒí˜• ê·¸ë¦¬ê¸°
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    let pointsDrawn = 0;
                    for (let i = 0; i < viewData.length; i += step) {
                        const sample = viewData[i] || 0;
                        const amplifiedSample = sample * amplificationFactor;
                        const x = (pointsDrawn / maxPoints) * width;
                        const y = height / 2 - (amplifiedSample * height * 0.4);
                        
                        if (pointsDrawn === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        pointsDrawn++;
                        
                        if (pointsDrawn >= maxPoints) break;
                    }
                    
                    ctx.stroke();
                    
                    // ì¤‘ì•™ì„ ê³¼ ê²©ì
                    ctx.strokeStyle = '#bdc3c7';
                    ctx.lineWidth = 1;
                    
                    // ì¤‘ì•™ì„ 
                    ctx.beginPath();
                    ctx.moveTo(0, height / 2);
                    ctx.lineTo(width, height / 2);
                    ctx.stroke();
                    
                    // ê²©ìì„ 
                    ctx.setLineDash([3, 3]);
                    const levels = [0.2, 0.4, 0.6, 0.8];
                    
                    for (const level of levels) {
                        ctx.beginPath();
                        ctx.moveTo(0, height / 2 - (height * level * 0.4));
                        ctx.lineTo(width, height / 2 - (height * level * 0.4));
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(0, height / 2 + (height * level * 0.4));
                        ctx.lineTo(width, height / 2 + (height * level * 0.4));
                        ctx.stroke();
                    }
                    
                    ctx.setLineDash([]);
                    
                    // ì‹œê°„ ì¶• ë¼ë²¨ (í˜„ì¬ ë³´ê¸° ì°½ ê¸°ì¤€)
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    
                    const timeLabels = [
                        this.scrollOffset,
                        this.scrollOffset + viewDuration * 0.25,
                        this.scrollOffset + viewDuration * 0.5,
                        this.scrollOffset + viewDuration * 0.75,
                        this.scrollOffset + viewDuration
                    ];
                    const xPositions = [0, width/4, width/2, 3*width/4, width];
                    
                    for (let i = 0; i < timeLabels.length; i++) {
                        ctx.fillText(`${timeLabels[i].toFixed(3)}s`, xPositions[i], height - 10);
                    }
                    
                    // ì§„í­ ë¼ë²¨
                    ctx.textAlign = 'right';
                    ctx.fillText(`+${maxAmplitude.toFixed(3)}`, width - 5, 25);
                    ctx.fillText('0.000', width - 5, height / 2 + 5);
                    ctx.fillText(`-${maxAmplitude.toFixed(3)}`, width - 5, height - 25);
                    
                    // ìƒíƒœ ì •ë³´ í‘œì‹œ
                    ctx.textAlign = 'left';
                    ctx.font = '10px Arial';
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillText(`ì¤Œ: ${this.zoomLevel.toFixed(1)}x | ì¦í­: ${amplificationFactor.toFixed(1)}x`, 10, 20);
                    
                    // ìŠ¤í¬ë¡¤ë°” í‘œì‹œ
                    this.drawScrollbar(ctx, width, height, totalDuration, viewDuration);
                    
                    // ì¡°ì‘ ì•ˆë‚´
                    ctx.fillStyle = '#95a5a6';
                    ctx.font = '9px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText('ë“œë˜ê·¸: ìŠ¤í¬ë¡¤ | íœ : ì¤Œ | ë”ë¸”í´ë¦­: ë¦¬ì…‹', width - 10, height - 25);
                    
                    console.log('ìŠ¤í¬ë¡¤ ê°€ëŠ¥í•œ íŒŒí˜• ì°¨íŠ¸ ì™„ë£Œ');
                    
                } catch (error) {
                    console.error('ìŠ¤í¬ë¡¤ íŒŒí˜• ì°¨íŠ¸ ì˜¤ë¥˜:', error);
                }
            }
            
            drawScrollbar(ctx, width, height, totalDuration, viewDuration) {
                // ìŠ¤í¬ë¡¤ë°” ë°°ê²½
                const scrollbarHeight = 8;
                const scrollbarY = height - 40;
                
                ctx.fillStyle = '#ecf0f1';
                ctx.fillRect(0, scrollbarY, width, scrollbarHeight);
                
                // ìŠ¤í¬ë¡¤ë°” í•¸ë“¤
                const handleWidth = (viewDuration / totalDuration) * width;
                const handleX = (this.scrollOffset / totalDuration) * width;
                
                ctx.fillStyle = '#3498db';
                ctx.fillRect(handleX, scrollbarY, handleWidth, scrollbarHeight);
                
                // ìŠ¤í¬ë¡¤ë°” í…Œë‘ë¦¬
                ctx.strokeStyle = '#bdc3c7';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, scrollbarY, width, scrollbarHeight);
            }
            
            drawRealSpectrum(spectrum, freqBins, sampleRate) {
                try {
                    console.log('ì‹¤ì œ FFT ìŠ¤í™íŠ¸ëŸ¼ ì°¨íŠ¸ ê·¸ë¦¬ê¸°...');
                    const canvas = document.getElementById('spectrumChart');
                    if (!canvas) return;
                    
                    const ctx = canvas.getContext('2d');
                    
                    // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width || 600;
                    canvas.height = rect.height || 300;
                    
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#f8f9fa';
                    ctx.fillRect(0, 0, width, height);
                    
                    if (spectrum.length === 0) return;
                    
                    // í‘œì‹œí•  ì£¼íŒŒìˆ˜ ë²”ìœ„ (0 ~ 5000Hz)
                    const maxFreq = Math.min(5000, sampleRate / 2);
                    const displaySpectrum = [];
                    const displayFreqs = [];
                    
                    // ì£¼íŒŒìˆ˜ ë¹ˆì´ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ê³„ì‚°
                    if (freqBins.length > 0) {
                        for (let i = 0; i < spectrum.length && i < freqBins.length; i++) {
                            if (freqBins[i] <= maxFreq) {
                                displaySpectrum.push(spectrum[i]);
                                displayFreqs.push(freqBins[i]);
                            }
                        }
                    } else {
                        // í´ë°±: ì£¼íŒŒìˆ˜ ë¹ˆ ê³„ì‚°
                        for (let i = 0; i < spectrum.length; i++) {
                            const freq = (i / spectrum.length) * (sampleRate / 2);
                            if (freq <= maxFreq) {
                                displaySpectrum.push(spectrum[i]);
                                displayFreqs.push(freq);
                            }
                        }
                    }
                    
                    console.log('ìŠ¤í™íŠ¸ëŸ¼ í‘œì‹œ ì •ë³´:', {
                        originalLength: spectrum.length,
                        displayLength: displaySpectrum.length,
                        maxFreq: maxFreq,
                        freqRange: displayFreqs.length > 0 ? 
                            `${displayFreqs[0].toFixed(1)} - ${displayFreqs[displayFreqs.length-1].toFixed(1)} Hz` : 'N/A'
                    });
                    
                    if (displaySpectrum.length === 0) return;
                    
                    // ë¡œê·¸ ìŠ¤ì¼€ì¼ ì£¼íŒŒìˆ˜ì¶• ì„¤ì •
                    const useLogScale = true;
                    const minFreq = Math.max(20, displayFreqs[0] || 20); // ìµœì†Œ 20Hz
                    
                    // ë§‰ëŒ€ ê·¸ë˜í”„ë¡œ ê·¸ë¦¬ê¸°
                    const barWidth = width / displaySpectrum.length;
                    
                    for (let i = 0; i < displaySpectrum.length; i++) {
                        const magnitude = displaySpectrum[i];
                        const freq = displayFreqs[i];
                        
                        let x;
                        if (useLogScale && freq > 0) {
                            // ë¡œê·¸ ìŠ¤ì¼€ì¼
                            const logMin = Math.log10(minFreq);
                            const logMax = Math.log10(maxFreq);
                            const logFreq = Math.log10(Math.max(freq, minFreq));
                            x = ((logFreq - logMin) / (logMax - logMin)) * width;
                        } else {
                            // ì„ í˜• ìŠ¤ì¼€ì¼
                            x = (freq / maxFreq) * width;
                        }
                        
                        const barHeight = magnitude * (height - 60); // ì—¬ë°± ê³ ë ¤
                        const y = height - barHeight - 30;
                        
                        // ì£¼íŒŒìˆ˜ì— ë”°ë¥¸ ìƒ‰ìƒ (íŒŒë€ìƒ‰ -> ë¹¨ê°„ìƒ‰)
                        const hue = 240 - (freq / maxFreq) * 180; // 240(íŒŒë€ìƒ‰) -> 60(ë…¸ë€ìƒ‰) -> 0(ë¹¨ê°„ìƒ‰)
                        const saturation = 70;
                        const lightness = 50;
                        const alpha = 0.7 + magnitude * 0.3; // í¬ê¸°ì— ë”°ë¼ íˆ¬ëª…ë„ ì¡°ì ˆ
                        
                        ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                        
                        // ë§‰ëŒ€ ë„ˆë¹„ ê³„ì‚° (ë¡œê·¸ ìŠ¤ì¼€ì¼ ê³ ë ¤)
                        let nextX = width;
                        if (i < displaySpectrum.length - 1) {
                            const nextFreq = displayFreqs[i + 1];
                            if (useLogScale && nextFreq > 0) {
                                const logMin = Math.log10(minFreq);
                                const logMax = Math.log10(maxFreq);
                                const logNextFreq = Math.log10(Math.max(nextFreq, minFreq));
                                nextX = ((logNextFreq - logMin) / (logMax - logMin)) * width;
                            } else {
                                nextX = (nextFreq / maxFreq) * width;
                            }
                        }
                        
                        const actualBarWidth = Math.max(1, nextX - x);
                        ctx.fillRect(x, y, actualBarWidth, barHeight);
                    }
                    
                    // ì£¼íŒŒìˆ˜ ì¶• ë¼ë²¨ (ë¡œê·¸ ìŠ¤ì¼€ì¼)
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'center';
                    
                    const freqLabels = useLogScale ? 
                        [20, 50, 100, 200, 500, 1000, 2000, 5000] :
                        [0, maxFreq/4, maxFreq/2, 3*maxFreq/4, maxFreq];
                    
                    for (const freq of freqLabels) {
                        if (freq <= maxFreq && freq >= minFreq) {
                            let x;
                            if (useLogScale) {
                                const logMin = Math.log10(minFreq);
                                const logMax = Math.log10(maxFreq);
                                const logFreq = Math.log10(freq);
                                x = ((logFreq - logMin) / (logMax - logMin)) * width;
                            } else {
                                x = (freq / maxFreq) * width;
                            }
                            
                            let label;
                            if (freq >= 1000) {
                                label = `${(freq/1000).toFixed(freq % 1000 === 0 ? 0 : 1)}k`;
                            } else {
                                label = `${freq}`;
                            }
                            
                            ctx.fillText(label, x, height - 5);
                            
                            // ê²©ìì„ 
                            ctx.strokeStyle = '#e0e0e0';
                            ctx.lineWidth = 1;
                            ctx.setLineDash([2, 2]);
                            ctx.beginPath();
                            ctx.moveTo(x, height - 30);
                            ctx.lineTo(x, 30);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                    }
                    
                    // dB ì¶• ë¼ë²¨
                    ctx.textAlign = 'right';
                    ctx.fillText('0dB', width - 5, 35);
                    ctx.fillText('-20dB', width - 5, height/2);
                    ctx.fillText('-40dB', width - 5, height - 35);
                    
                    // ì œëª©ê³¼ ì •ë³´
                    ctx.textAlign = 'left';
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#2c3e50';
                    ctx.fillText('ì£¼íŒŒìˆ˜ ìŠ¤í™íŠ¸ëŸ¼ (ì‹¤ì œ FFT)', 10, 20);
                    
                    ctx.font = '10px Arial';
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillText(`FFT í¬ê¸°: ${spectrum.length * 2} | ${useLogScale ? 'ë¡œê·¸' : 'ì„ í˜•'} ìŠ¤ì¼€ì¼`, 10, height - 10);
                    
                    // ì£¼ìš” í”¼í¬ í‘œì‹œ
                    this.markSpectralPeaks(ctx, displaySpectrum, displayFreqs, width, height, useLogScale, minFreq, maxFreq);
                    
                    console.log('ì‹¤ì œ FFT ìŠ¤í™íŠ¸ëŸ¼ ì°¨íŠ¸ ì™„ë£Œ');
                    
                } catch (error) {
                    console.error('ì‹¤ì œ ìŠ¤í™íŠ¸ëŸ¼ ì°¨íŠ¸ ì˜¤ë¥˜:', error);
                }
            }
            
            markSpectralPeaks(ctx, spectrum, freqs, width, height, useLogScale, minFreq, maxFreq) {
                try {
                    // í”¼í¬ ì°¾ê¸° (ì„ê³„ê°’ ì´ìƒ)
                    const threshold = Math.max(...spectrum) * 0.3; // 30% ì„ê³„ê°’
                    const peaks = [];
                    
                    for (let i = 1; i < spectrum.length - 1; i++) {
                        if (spectrum[i] > threshold && 
                            spectrum[i] > spectrum[i-1] && 
                            spectrum[i] > spectrum[i+1]) {
                            peaks.push({ freq: freqs[i], magnitude: spectrum[i], index: i });
                        }
                    }
                    
                    // ìƒìœ„ 3ê°œ í”¼í¬ë§Œ í‘œì‹œ
                    peaks.sort((a, b) => b.magnitude - a.magnitude);
                    const topPeaks = peaks.slice(0, 3);
                    
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '9px Arial';
                    ctx.textAlign = 'center';
                    
                    for (const peak of topPeaks) {
                        let x;
                        if (useLogScale && peak.freq > 0) {
                            const logMin = Math.log10(minFreq);
                            const logMax = Math.log10(maxFreq);
                            const logFreq = Math.log10(Math.max(peak.freq, minFreq));
                            x = ((logFreq - logMin) / (logMax - logMin)) * width;
                        } else {
                            x = (peak.freq / maxFreq) * width;
                        }
                        
                        const y = height - peak.magnitude * (height - 60) - 30;
                        
                        // í”¼í¬ ë§ˆì»¤
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // ì£¼íŒŒìˆ˜ ë¼ë²¨
                        const freqLabel = peak.freq >= 1000 ? 
                            `${(peak.freq/1000).toFixed(1)}kHz` : 
                            `${Math.round(peak.freq)}Hz`;
                        
                        ctx.fillText(freqLabel, x, y - 8);
                    }
                    
                } catch (error) {
                    console.error('í”¼í¬ í‘œì‹œ ì˜¤ë¥˜:', error);
                }
            }
            
            // ì‹¤ì‹œê°„ ë…¹ìŒ ê¸°ëŠ¥ (ì›ë³¸ ê·¸ëŒ€ë¡œ ë³µì›)
          async startRealTimeRecording() {
                try {
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('ì´ ë¸Œë¼ìš°ì €ëŠ” ë§ˆì´í¬ ì ‘ê·¼ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                    }
                    
                    // ê°¤ëŸ­ì‹œ ìµœì í™”: AudioContext ë¨¼ì € ìƒì„± ë° í™œì„±í™”
                    console.log('AudioContext ìƒì„± ë° í™œì„±í™”...');
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                        console.log('AudioContext í™œì„±í™” ì™„ë£Œ:', this.audioContext.state);
                    }
                    
                    // ê°¤ëŸ­ì‹œ(Android Chrome) ìµœì í™” ì˜¤ë””ì˜¤ ì„¤ì •
                    const constraints = {
                        audio: {
                            sampleRate: 44100,
                            channelCount: 1,
                            echoCancellation: true,     // ê°¤ëŸ­ì‹œì—ì„œ ì¤‘ìš”
                            noiseSuppression: true,     // ê°¤ëŸ­ì‹œì—ì„œ ì¤‘ìš”
                            autoGainControl: false
                        }
                    };
                    
                    console.log('ë§ˆì´í¬ ìŠ¤íŠ¸ë¦¼ ìš”ì²­ ì¤‘...');
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log('ë§ˆì´í¬ ìŠ¤íŠ¸ë¦¼ íšë“ ì„±ê³µ');
                    
                    // ê°¤ëŸ­ì‹œìš© MIME íƒ€ì… ì²´í¬ (ìš°ì„ ìˆœìœ„: webm > mp4 > wav)
                    let options = {};
                    let mimeType = 'audio/webm;codecs=opus';  // ê°¤ëŸ­ì‹œ ì„ í˜¸ í¬ë§·
                    
                    if (MediaRecorder.isTypeSupported(mimeType)) {
                        options.mimeType = mimeType;
                        console.log('MIME íƒ€ì… ì„¤ì •: audio/webm;codecs=opus');
                    } else if (MediaRecorder.isTypeSupported('audio/webm')) {
                        options.mimeType = 'audio/webm';
                        console.log('MIME íƒ€ì… ì„¤ì •: audio/webm');
                    } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                        options.mimeType = 'audio/mp4';
                        console.log('MIME íƒ€ì… ì„¤ì •: audio/mp4');
                    } else if (MediaRecorder.isTypeSupported('audio/wav')) {
                        options.mimeType = 'audio/wav';
                        console.log('MIME íƒ€ì… ì„¤ì •: audio/wav');
                    } else {
                        console.log('ê¸°ë³¸ MIME íƒ€ì… ì‚¬ìš©');
                    }
                    
                    console.log('MediaRecorder ì„¤ì •:', options);
                    
                    this.mediaRecorder = new MediaRecorder(stream, options);
                    this.recordedChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        console.log('ë°ì´í„° ìˆ˜ì‹ :', event.data.size, 'bytes');
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = async () => {
                        console.log('ë…¹ìŒ ì¤‘ì§€, ì´ ì²­í¬:', this.recordedChunks.length);
                        const finalMimeType = this.mediaRecorder.mimeType || options.mimeType || 'audio/wav';
                        const audioBlob = new Blob(this.recordedChunks, { type: finalMimeType });
                        console.log('ìƒì„±ëœ Blob:', audioBlob.size, 'bytes, type:', audioBlob.type);
                        await this.processRecordedAudio(audioBlob);
                    };
                    
                    this.mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder ì˜¤ë¥˜:', event.error);
                        this.updateStatus(`ë…¹ìŒ ì¤‘ ì˜¤ë¥˜: ${event.error.message}`, 'error');
                    };
                    
                    this.currentStream = stream;
                    this.isRecording = true;
                    
                    // ê°¤ëŸ­ì‹œ ìµœì í™”: ë” ê¸´ ê°„ê²©ìœ¼ë¡œ ë°ì´í„° ìˆ˜ì§‘ (ì•ˆì •ì„± í–¥ìƒ)
                    this.mediaRecorder.start(2000); // 1ì´ˆ â†’ 2ì´ˆë¡œ ì¦ê°€
                    console.log('ë…¹ìŒ ì‹œì‘ (2ì´ˆ ê°„ê²©)');
                    
                    const recordBtn = document.getElementById('recordBtn');
                    recordBtn.textContent = 'ğŸ”´ ë…¹ìŒ ì¤‘...';
                    recordBtn.classList.add('recording');
                    
                    this.updateStatus('ì‹¤ì‹œê°„ ë…¹ìŒ ì¤‘ì…ë‹ˆë‹¤. ì¬ì§ˆì„ íƒ€ê²©í•˜ê³  ìµœì†Œ 3ì´ˆ ì´ìƒ ë…¹ìŒí•´ì£¼ì„¸ìš”.', 'analyzing');
                    
                    // ìë™ ì¤‘ì§€ íƒ€ì´ë¨¸ (10ì´ˆ í›„)
                    this.autoStopTimer = setTimeout(() => {
                        if (this.isRecording) {
                            console.log('ìë™ ì¤‘ì§€ (10ì´ˆ ê²½ê³¼)');
                            this.stopRealTimeRecording();
                        }
                    }, 10000);
                    
                } catch (error) {
                    console.error('ì‹¤ì‹œê°„ ë…¹ìŒ ì˜¤ë¥˜:', error);
                    
                    // ê°¤ëŸ­ì‹œìš© ìƒì„¸ ì—ëŸ¬ ë©”ì‹œì§€
                    let errorMessage = 'ì‹¤ì‹œê°„ ë…¹ìŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ';
                    if (error.name === 'NotAllowedError') {
                        errorMessage = 'ë§ˆì´í¬ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.';
                    } else if (error.name === 'NotFoundError') {
                        errorMessage = 'ë§ˆì´í¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¸°ê¸°ì— ë§ˆì´í¬ê°€ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.';
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage = 'ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ë…¹ìŒì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Chrome ë¸Œë¼ìš°ì €ë¥¼ ì‚¬ìš©í•´ë³´ì„¸ìš”.';
                    } else {
                        errorMessage += error.message;
                    }
                    
                    this.updateStatus(errorMessage, 'error');
                }
            }
            
            stopRealTimeRecording() {
                if (this.isRecording && this.mediaRecorder) {
                    console.log('ë…¹ìŒ ì¤‘ì§€ ìš”ì²­');
                    
                    // ìë™ ì¤‘ì§€ íƒ€ì´ë¨¸ í•´ì œ
                    if (this.autoStopTimer) {
                        clearTimeout(this.autoStopTimer);
                        this.autoStopTimer = null;
                    }
                    
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    
                    if (this.currentStream) {
                        this.currentStream.getTracks().forEach(track => {
                            track.stop();
                            console.log('íŠ¸ë™ ì¤‘ì§€:', track.kind);
                        });
                        this.currentStream = null;
                    }
                    
                    if (this.audioContext && this.audioContext.state !== 'closed') {
                        this.audioContext.close();
                        this.audioContext = null;
                    }
                    
                    const recordBtn = document.getElementById('recordBtn');
                    recordBtn.textContent = 'ğŸ¤ ì‹¤ì‹œê°„ ë…¹ìŒ';
                    recordBtn.classList.remove('recording');
                    
                    this.updateStatus('ë…¹ìŒì„ ì¤‘ì§€í•˜ê³  ë¶„ì„ì„ ì‹œì‘í•©ë‹ˆë‹¤...', 'analyzing');
                    console.log('ë…¹ìŒ ì¤‘ì§€ ì™„ë£Œ');
                }
            }
            
            async processRecordedAudio(audioBlob) {
                try {
                    console.log('ë…¹ìŒëœ Blob ì •ë³´:', {
                        size: audioBlob.size,
                        type: audioBlob.type
                    });
                    
                    // 1ë‹¨ê³„: Blob í¬ê¸° í™•ì¸
                    if (audioBlob.size < 1000) {
                        throw new Error('ë…¹ìŒ ë°ì´í„°ê°€ ë„ˆë¬´ ì‘ìŠµë‹ˆë‹¤. ë” ì˜¤ë˜ ë…¹ìŒí•´ì£¼ì„¸ìš”.');
                    }
                    
                    // 2ë‹¨ê³„: ArrayBuffer ë³€í™˜
                    console.log('ArrayBuffer ë³€í™˜ ì¤‘...');
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    console.log('ArrayBuffer í¬ê¸°:', arrayBuffer.byteLength);
                    
                    // 3ë‹¨ê³„: ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
                    console.log('AudioContext ìƒì„± ì¤‘...');
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // 4ë‹¨ê³„: ì˜¤ë””ì˜¤ ë””ì½”ë”© (ë” ì•ˆì „í•œ ë°©ë²•)
                    console.log('ì˜¤ë””ì˜¤ ë””ì½”ë”© ì¤‘...');
                    let audioBuffer;
                    
                    try {
                        audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        console.log('ë””ì½”ë”© ì„±ê³µ:', {
                            duration: audioBuffer.duration,
                            sampleRate: audioBuffer.sampleRate,
                            channels: audioBuffer.numberOfChannels
                        });
                    } catch (decodeError) {
                        console.error('ë””ì½”ë”© ì˜¤ë¥˜:', decodeError);
                        
                        // í´ë°±: WAV í˜•ì‹ìœ¼ë¡œ ì¬ì‹œë„
                        console.log('WAV í˜•ì‹ìœ¼ë¡œ ì¬ì‹œë„...');
                        const wavBlob = await this.convertToWav(audioBlob);
                        const wavArrayBuffer = await wavBlob.arrayBuffer();
                        audioBuffer = await audioContext.decodeAudioData(wavArrayBuffer);
                    }
                    
                    // 5ë‹¨ê³„: ì˜¤ë””ì˜¤ ë²„í¼ ìœ íš¨ì„± í™•ì¸
                    if (!audioBuffer || audioBuffer.duration < 0.1) {
                        throw new Error('ìœ íš¨í•˜ì§€ ì•Šì€ ì˜¤ë””ì˜¤ ë°ì´í„°ì…ë‹ˆë‹¤.');
                    }
                    
                    // 6ë‹¨ê³„: ë¶„ì„ ì‹¤í–‰
                    console.log('ë¶„ì„ ì‹œì‘...');
                    await this.analyzeAudioBuffer(audioBuffer);
                    
                } catch (error) {
                    console.error('ë…¹ìŒ ë°ì´í„° ì²˜ë¦¬ ì˜¤ë¥˜:', error);
                    
                    let errorMessage = 'ë…¹ìŒ ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ';
                    
                    if (error.message.includes('ë„ˆë¬´ ì‘ìŠµë‹ˆë‹¤')) {
                        errorMessage = 'ë…¹ìŒ ì‹œê°„ì´ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤. 3ì´ˆ ì´ìƒ ë…¹ìŒí•´ì£¼ì„¸ìš”.';
                    } else if (error.message.includes('ë””ì½”ë”©')) {
                        errorMessage = 'ì˜¤ë””ì˜¤ í˜•ì‹ì„ ì¸ì‹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ë¸Œë¼ìš°ì €ë¥¼ ì‹œë„í•´ë³´ì„¸ìš”.';
                    } else if (error.message.includes('ìœ íš¨í•˜ì§€ ì•Šì€')) {
                        errorMessage = 'ë…¹ìŒëœ ì˜¤ë””ì˜¤ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë…¹ìŒí•´ì£¼ì„¸ìš”.';
                    } else {
                        errorMessage += error.message;
                    }
                    
                    this.updateStatus(errorMessage, 'error');
                    
                    // ë””ë²„ê·¸ ì •ë³´ í‘œì‹œ
                    this.showDebugInfo(error, audioBlob);
                }
            }
            
            async convertToWav(audioBlob) {
                // ê°„ë‹¨í•œ WAV ë³€í™˜ (ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ ë³€í™˜ í•„ìš”)
                return audioBlob; // ì„ì‹œ êµ¬í˜„
            }
            
            showDebugInfo(error, audioBlob) {
                const debugInfo = `
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 10px; padding: 15px; margin: 15px 0; font-size: 0.9em;">
                        <h4 style="color: #856404; margin-bottom: 10px;">ğŸ”§ ë””ë²„ê·¸ ì •ë³´</h4>
                        <p><strong>ì˜¤ë¥˜:</strong> ${error.message}</p>
                        <p><strong>Blob í¬ê¸°:</strong> ${audioBlob.size} bytes</p>
                        <p><strong>Blob íƒ€ì…:</strong> ${audioBlob.type}</p>
                        <p><strong>ë¸Œë¼ìš°ì €:</strong> ${navigator.userAgent}</p>
                        <p style="margin-top: 10px; color: #856404;">
                            <strong>í•´ê²° ë°©ë²•:</strong><br>
                            1. ë” ì˜¤ë˜ ë…¹ìŒí•˜ê¸° (3ì´ˆ ì´ìƒ)<br>
                            2. ë‹¤ë¥¸ ë¸Œë¼ìš°ì € ì‹œë„<br>
                            3. íŒŒì¼ ì—…ë¡œë“œ ë°©ì‹ ì‚¬ìš©
                        </p>
                    </div>
                `;
                
                const container = document.querySelector('.container');
                const existingDebug = container.querySelector('.debug-info');
                if (existingDebug) {
                    existingDebug.remove();
                }
                
                const debugDiv = document.createElement('div');
                debugDiv.className = 'debug-info';
                debugDiv.innerHTML = debugInfo;
                container.appendChild(debugDiv);
            }
            
            clearAll() {
                document.getElementById('resultsSection').classList.add('hidden');
                document.getElementById('fileInput').value = '';
                this.updateStatus('ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê±°ë‚˜ ì‹¤ì‹œê°„ ë…¹ìŒì„ ì‹œì‘í•˜ì„¸ìš”.', 'ready');
                
                // íŒŒí˜• ë°ì´í„° ì´ˆê¸°í™”
                this.waveformData = null;
                this.waveformSampleRate = 44100;
                this.scrollOffset = 0;
                this.zoomLevel = 1;
                
                // ê²°ê³¼ ì´ˆê¸°í™”
                document.getElementById('predictedMaterial').style.display = 'none';
                document.getElementById('confidence').style.display = 'none';
                
                // ê°’ë“¤ ì´ˆê¸°í™”
                const elements = ['resonantFreq', 'qFactor', 'harmonicRatio', 'decayCoeff', 'halfLife', 'rSquared', 'maxAmplitude', 'duration', 'snr', 'freqMatch', 'decayPattern', 'totalScore'];
                elements.forEach(id => {
                    document.getElementById(id).textContent = '--';
                });
            }
            
            updateStatus(message, type) {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status status-${type}`;
            }
        }
        
        // ì•± ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            new OfflineMaterialAnalyzer();
        });
    </script>
</body>
</html>