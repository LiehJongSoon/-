<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ïû¨Ïßà Í≥µÎ™Ö Î∂ÑÏÑùÍ∏∞ - Ï∞®Ìä∏ Í∞úÏÑ† Î≤ÑÏ†Ñ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Malgun Gothic', 'ÎßëÏùÄ Í≥†Îîï', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
        }
        
        .input-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #764ba2;
            background: rgba(102, 126, 234, 0.05);
        }
        
        .upload-area.dragover {
            border-color: #764ba2;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }
        
        .upload-icon {
            font-size: 4em;
            color: #667eea;
            margin-bottom: 20px;
            display: block;
        }
        
        .upload-text {
            font-size: 1.3em;
            color: #2c3e50;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .upload-subtext {
            color: #7f8c8d;
            font-size: 1em;
        }
        
        .file-input {
            display: none;
        }
        
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 10px;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
            color: white;
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(149, 165, 166, 0.4);
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .manual-toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0 4px 0;
            flex-wrap: wrap;
            font-size: 12px;
        }
        .manual-toolbar .btn-mini {
            padding: 6px 10px;
            border-radius: 10px;
            font-size: 12px;
            border: 1px solid #dfe6e9;
            background: #f5f6fa;
            cursor: pointer;
        }
        .manual-toolbar .btn-mini.active {
            background: #dfe6ff;
            border-color: #667eea;
        }
        .manual-info {
            margin-left: auto;
            color: #2c3e50;
            font-weight: 600;
        }
        .db-toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0 0 0;
            font-size: 12px;
        }
        .db-toolbar input[type="number"] {
            width: 70px;
            padding: 4px 6px;
            border: 1px solid #dfe6e9;
            border-radius: 8px;
        }
        
        .chart-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .chart-canvas {
            width: 100%;
            height: 300px;
            border: 1px solid #ecf0f1;
            border-radius: 10px;
        }
        
        .results {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            grid-column: 1 / -1;
        }
        
        .results-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .material-prediction {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .predicted-material {
            font-size: 2em;
            font-weight: bold;
            padding: 15px 30px;
            border-radius: 15px;
            color: white;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: none;
        }
        
        .material-wood { background: linear-gradient(45deg, #8b4513, #a0522d); }
        .material-ceramic { background: linear-gradient(45deg, #f39c12, #e67e22); }
        .material-iron { background: linear-gradient(45deg, #95a5a6, #7f8c8d); }
        .material-aluminum { background: linear-gradient(45deg, #3498db, #2980b9); }
        
        .confidence {
            font-size: 1.2em;
            color: #2c3e50;
            display: none;
        }
        
        .analysis-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .detail-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border-left: 5px solid #667eea;
        }
        
        .detail-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .detail-value {
            font-size: 1.1em;
            color: #34495e;
            margin-bottom: 5px;
        }
        
        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        
        .status-ready {
            background: #d5f4e6;
            color: #27ae60;
        }
        
        .status-analyzing {
            background: #74b9ff;
            color: #0984e3;
        }
        
        .status-complete {
            background: #fd79a8;
            color: #e84393;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .analysis-grid {
                grid-template-columns: 1fr;
            }
            
            .analysis-details {
                grid-template-columns: 1fr;
            }
            
            .material-prediction {
                flex-direction: column;
            }
        }
        
        .realtime-section {
            background: #fff3cd;
            border: 2px solid #ffeaa7;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .realtime-title {
            color: #856404;
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .realtime-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn-record {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }
        
        .btn-record:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
        }
        
        .btn-record.recording {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            animation: pulse 1.5s infinite;
        }
        
        .btn-stop {
            background: linear-gradient(45deg, #34495e, #2c3e50);
            color: white;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
#harmonicRatio,
      .detail-value:has(#harmonicRatio),
      #rSquared,
      .detail-value:has(#rSquared),
      #snr,
      .detail-value:has(#snr) {
          display: none !important;
      }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéµ ÏÜåÎ¶¨Ïó∞Íµ¨ÏÜå</h1>
            <p class="subtitle"><strong>Ï£ºÌååÏàò Î∂ÑÏÑù + Í∞úÏÑ†Îêú Í∞êÏá† Î™®Îç∏ÏùÑ ÌÜµÌïú Ïã§ÏÉùÌôú ÏÜåÎ¶¨ Ï∏°Ï†ï/Î∂ÑÏÑù</strong></p>
        </div>
        
        <div id="status" class="status status-ready">
            Ïò§ÎîîÏò§ ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌïòÍ±∞ÎÇò Ïã§ÏãúÍ∞Ñ ÎÖπÏùåÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî.
        </div>
        
        <!-- Ïã§ÏãúÍ∞Ñ ÎÖπÏùå ÏÑπÏÖò -->
        <div class="realtime-section">
            <div class="realtime-title">üé§ Ïã§ÏãúÍ∞Ñ Î∂ÑÏÑù (ÏÑ†ÌÉùÏÇ¨Ìï≠)</div>
            <p style="color: #856404; margin-bottom: 15px;">ÎßàÏù¥ÌÅ¨Í∞Ä ÏßÄÏõêÎêòÎäî ÌôòÍ≤ΩÏóêÏÑú Ïã§ÏãúÍ∞Ñ Î∂ÑÏÑùÏùÑ ÏãúÎèÑÌï† Ïàò ÏûàÏäµÎãàÎã§.</p>
            <div class="realtime-buttons">
                <button id="recordBtn" class="btn btn-record">üé§ Ïã§ÏãúÍ∞Ñ ÎÖπÏùå</button>
                <button id="stopBtn" class="btn btn-stop">‚èπÔ∏è Ï§ëÏßÄ</button>
            </div>
        </div>
        
        <!-- ÌååÏùº ÏóÖÎ°úÎìú ÏÑπÏÖò -->
        <div class="input-section">
            <div class="upload-area" id="uploadArea">
                <span class="upload-icon">üìÅ</span>
                <div class="upload-text">Ïò§ÎîîÏò§ ÌååÏùºÏùÑ Ïó¨Í∏∞Ïóê ÎìúÎûòÍ∑∏ÌïòÍ±∞ÎÇò ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî</div>
                <div class="upload-subtext">ÏßÄÏõê ÌòïÏãù: MP3, WAV, M4A, OGG (ÏµúÎåÄ 10MB)</div>
            </div>
            <input type="file" id="fileInput" class="file-input" accept="audio/*">
            <button id="uploadBtn" class="btn btn-primary">üìÇ ÌååÏùº ÏÑ†ÌÉù</button>
            <button id="clearBtn" class="btn btn-secondary">üóëÔ∏è Ï¥àÍ∏∞Ìôî</button>
        </div>
        
        <!-- Î∂ÑÏÑù Í≤∞Í≥º ÏÑπÏÖò -->
        <div id="resultsSection" class="hidden">
            <div class="analysis-grid">
                <div class="chart-container">
                    <div class="chart-title">üìà ÏãúÍ∞Ñ ÏòÅÏó≠ ÌååÌòï<br> 
<small>xÏ∂ï: ÏãúÍ∞Ñ(s) / yÏ∂ï: ÏßÑÌè≠ (‚Äì1~+1, norm. PCM)</small></div>
                    <div class="manual-toolbar">
                        <button id="manualToggleBtn" class="btn-mini">üñ±Ô∏è Ï£ºÍ∏∞Ïûê Î™®Îìú</button>
                        <button id="manualUndoBtn" class="btn-mini">‚Ü©Ô∏è ÎêòÎèåÎ¶¨Í∏∞</button>
                        <button id="manualResetBtn" class="btn-mini">üóëÔ∏è Ï¥àÍ∏∞Ìôî</button>
                        <label style="display:flex; align-items:center; gap:6px;">
                            <input type="checkbox" id="manualSnapChk" checked>
                            Ïä§ÎÉÖ-Ìà¨-ÌîºÌÅ¨
                        </label>
                        <span id="manualInfo" class="manual-info">‚Äî</span>
                    </div>
                    <div class="db-toolbar">
                        <label style="display:flex; align-items:center; gap:6px;">
                            <input type="checkbox" id="dbToggleChk">
                            dB ÌëúÏãú(ÏãúÍ∞ÑÏòÅÏó≠)
                        </label>
                        <label style="display:flex; align-items:center; gap:6px;">
                            ÌôòÍ≤Ω:
                            <select id="envSelect">
                                <option value="10">Ï°∞Ïö©Ìïú Î∞© (10dB)</option>
                                <option value="20" selected>ÍµêÏã§ (20dB)</option>
                                <option value="30">ÎèÑÏÑúÍ¥Ä (30dB)</option>
                                <option value="40">Ïã§Ïô∏ (40dB)</option>
                            </select>
                        </label>
                        <span id="dbHud">‚Äî</span>
                    </div>
                    <canvas id="waveformChart" class="chart-canvas"></canvas>
                </div>
                
                <div class="chart-container">
                    <div class="chart-title">üåä Ï£ºÌååÏàò Ïä§ÌéôÌä∏Îüº</div>
                    <canvas id="spectrumChart" class="chart-canvas"></canvas>
                </div>
            </div>
            
            <div class="results">
                <div class="results-title">üî¨ Î∂ÑÏÑù Í≤∞Í≥º(Î™®Îã¨ ÌååÎùºÎØ∏ÌÑ∞)</div>
                             
     
                <div class="analysis-details">
                    <div class="detail-card">
                        <div class="detail-title">üéµ Ï£ºÌååÏàò Î∂ÑÏÑù</div>
                        <div class="detail-value">Ï£ºÏöî Í≥µÎ™Ö Ï£ºÌååÏàò: <span id="resonantFreq">-- Hz</span></div>
                        <div class="detail-value">Q-Factor: <span id="qFactor">--</span></div>
                        <div class="detail-value">ÌïòÎ™®Îãâ ÎπÑÏú®: <span id="harmonicRatio">--%</span></div>
                    </div>
                    
                    <div class="detail-card">
                        <div class="detail-title">üìâ Í∞êÏá† Î∂ÑÏÑù</div>
                        <div class="detail-value">Í∞êÏá† Í≥ÑÏàò: <span id="decayCoeff">-- /s</span></div>
                        <div class="detail-value">Î∞òÍ∞êÍ∏∞: <span id="halfLife">-- s</span></div>
                        <div class="detail-value">R¬≤ Í∞í: <span id="rSquared">--</span></div>
                    </div>
                    
                    <div class="detail-card">
                        <div class="detail-title">üîä Ïã†Ìò∏ ÌäπÏÑ±</div>
                        <div class="detail-value">ÏµúÎåÄ ÏßÑÌè≠: <span id="maxAmplitude">-- dB</span></div>
                        <div class="detail-value">ÏßÄÏÜç ÏãúÍ∞Ñ: <span id="duration">-- s</span></div>
                        <div class="detail-value">Ïã†Ìò∏ ÎåÄ Ïû°ÏùåÎπÑ: <span id="snr">-- dB</span></div>
                    </div>
                    
<div class="detail-card">
    <div class="detail-title">üìà Ìè¨ÎùΩÏÑ† Ï∂îÏù¥</div>
    <canvas id="envelopeChart" style="width: 100%; height: 200px; border: 1px solid #ecf0f1; border-radius: 5px;"></canvas>
    <div style="font-size: 0.9em; color: #7f8c8d; margin-top: 5px; text-align: center;">
        Í∞êÏá† Ìè¨ÎùΩÏÑ† (10ms ÏÉòÌîåÎßÅ)
    </div>
</div>
                    
                </div>
            </div>
        </div>
    </div>

    <script>
        class OfflineMaterialAnalyzer {
            constructor() {
                this.audioContext = null;
                this.isRecording = false;
                this.audioData = [];
                this.sampleRate = 44100;
                this.currentStream = null;
                this.isCountingDown = false;
this.countdownInterval = null;

                // ÌååÌòï Ïä§ÌÅ¨Î°§ Í¥ÄÎ†® Î≥ÄÏàò
                this.waveformData = null;
                this.waveformSampleRate = 44100;
                this.scrollOffset = 0; // Ïä§ÌÅ¨Î°§ Ïò§ÌîÑÏÖã (Ï¥à Îã®ÏúÑ)
                this.zoomLevel = 1; // Ï§å Î†àÎ≤® (1 = Ï†ÑÏ≤¥, 2 = 2Î∞∞ ÌôïÎåÄ)
                this.isDragging = false;
                this.lastMouseX = 0;
                
                // Ïû¨ÏßàÎ≥Ñ ÌäπÏÑ± Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§
                this.materialDatabase = {
                    wood: {
                        resonantFreq: [200, 400, 800],
                        qFactor: [5, 15],
                        decayCoeff: [2, 8],
                        harmonicPattern: 'rich_low',
                        name: 'ÎÇòÎ¨¥',
                        class: 'material-wood'
                    },
                    ceramic: {
                        resonantFreq: [800, 1600, 3200],
                        qFactor: [15, 40],
                        decayCoeff: [1, 4],
                        harmonicPattern: 'clear_high',
                        name: 'ÎèÑÏûêÍ∏∞',
                        class: 'material-ceramic'
                    },
                    iron: {
                        resonantFreq: [400, 1200, 2400],
                        qFactor: [20, 60],
                        decayCoeff: [0.5, 3],
                        harmonicPattern: 'metallic',
                        name: 'Ï≤†',
                        class: 'material-iron'
                    },
                    aluminum: {
                        resonantFreq: [600, 1800, 3600],
                        qFactor: [25, 80],
                        decayCoeff: [0.3, 2],
                        harmonicPattern: 'bright_metallic',
                        name: 'ÏïåÎ£®ÎØ∏ÎäÑ',
                        class: 'material-aluminum'
                    }
                };
                
                // ÏàòÎèô Ïπ¥Ïö¥Ìä∏ ÏÉÅÌÉú
                this.manualMode = false;
                this.manualClicks = [];
                this.manualSnapToPeak = true;
                this.manualSelecting = false;
                this.manualSelStartX = null;
                this.manualSelEndX = null;
                this.manualAutoResult = null; // { f, startSample, endSample, crossings: [] }
                this.lastDominantFreq = null;

                // ÏãúÍ∞ÑÏòÅÏó≠ dB ÌëúÏãú ÏÉÅÌÉú
                this.dbToggle = false;
                this.envBaseLevel = 20; // ÌôòÍ≤Ω Í∏∞Ï§Ä ÏÜåÏùå Î†àÎ≤® (Í∏∞Î≥∏: ÍµêÏã§)

                this.initializeEvents();
            }
            
            initializeEvents() {
                // ÌååÏùº ÏóÖÎ°úÎìú Ïù¥Î≤§Ìä∏
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const uploadBtn = document.getElementById('uploadBtn');
                const clearBtn = document.getElementById('clearBtn');
                
                // Ïã§ÏãúÍ∞Ñ ÎÖπÏùå Ïù¥Î≤§Ìä∏
                const recordBtn = document.getElementById('recordBtn');
                const stopBtn = document.getElementById('stopBtn');
                
                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
                uploadArea.addEventListener('drop', this.handleDrop.bind(this));
                
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));
                uploadBtn.addEventListener('click', () => fileInput.click());
                clearBtn.addEventListener('click', this.clearAll.bind(this));
                
                recordBtn.addEventListener('click', this.startRealTimeRecording.bind(this));
                stopBtn.addEventListener('click', this.stopRealTimeRecording.bind(this));
                
                // ÌååÌòï Ï∞®Ìä∏ Ïä§ÌÅ¨Î°§ Ïù¥Î≤§Ìä∏ Ï∂îÍ∞Ä
                this.initializeWaveformEvents();

                // ÏàòÎèô Ïπ¥Ïö¥Ìä∏ ÎèÑÍµ¨ Ïù¥Î≤§Ìä∏
                const manualToggleBtn = document.getElementById('manualToggleBtn');
                const manualUndoBtn = document.getElementById('manualUndoBtn');
                const manualResetBtn = document.getElementById('manualResetBtn');
                const manualSnapChk = document.getElementById('manualSnapChk');
                if (manualToggleBtn) manualToggleBtn.addEventListener('click', () => this.toggleManualMode());
                if (manualUndoBtn) manualUndoBtn.addEventListener('click', () => this.manualUndo());
                if (manualResetBtn) manualResetBtn.addEventListener('click', () => this.manualReset());
                if (manualSnapChk) manualSnapChk.addEventListener('change', (e) => { this.manualSnapToPeak = !!e.target.checked; });

                // dB ÌëúÏãú Ïù¥Î≤§Ìä∏
                const dbToggleChk = document.getElementById('dbToggleChk');
                const envSelect = document.getElementById('envSelect');
                if (dbToggleChk) dbToggleChk.addEventListener('change', (e)=>{ this.dbToggle = !!e.target.checked; this.redrawWaveform(); });
                if (envSelect) envSelect.addEventListener('change', (e)=>{ this.envBaseLevel = parseInt(e.target.value); this.redrawWaveform(); });
            }
            
            initializeWaveformEvents() {
                const canvas = document.getElementById('waveformChart');
                
                // ÎßàÏö∞Ïä§ ÎìúÎûòÍ∑∏ Ïù¥Î≤§Ìä∏
                canvas.addEventListener('mousedown', this.onWaveformMouseDown.bind(this));
                canvas.addEventListener('mousemove', this.onWaveformMouseMove.bind(this));
                canvas.addEventListener('mouseup', this.onWaveformMouseUp.bind(this));
                canvas.addEventListener('mouseleave', this.onWaveformMouseUp.bind(this));
                
                // ÎßàÏö∞Ïä§ Ìú† Ïù¥Î≤§Ìä∏ (Ï§å)
                canvas.addEventListener('wheel', this.onWaveformWheel.bind(this));
                
                // ÎçîÎ∏îÌÅ¥Î¶≠ÏúºÎ°ú Î¶¨ÏÖã
                canvas.addEventListener('dblclick', this.resetWaveformView.bind(this));
                
// ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ (ÌïÄÏπò Ï§å + ÎìúÎûòÍ∑∏ Ïä§ÌÅ¨Î°§ + Ï£ºÍ∏∞Ïûê Î™®Îìú)
canvas.addEventListener('touchstart', this.onWaveformTouchStart.bind(this), { passive: false });
canvas.addEventListener('touchmove',  this.onWaveformTouchMove.bind(this),  { passive: false });
canvas.addEventListener('touchend',   this.onWaveformTouchEnd.bind(this),   { passive: false });


                // Ïª§ÏÑú Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
                canvas.style.cursor = 'grab';
            }
            
            onWaveformMouseDown(e) {
                if (this.manualMode) {
                    this.handleManualClick(e);
                    return;
                }
                this.isDragging = true;
                this.lastMouseX = e.offsetX;
                e.target.style.cursor = 'grabbing';
            }
            
            onWaveformMouseMove(e) {
                if (this.manualMode) {
                    if (!this.waveformData || !this.manualSelecting) return;
                    const canvas = document.getElementById('waveformChart');
                    const rect = canvas.getBoundingClientRect();
                    this.manualSelEndX = Math.max(0, Math.min(canvas.width, e.clientX - rect.left));
                    this.redrawWaveform();
                    return;
                }
                if (!this.isDragging || !this.waveformData) return;
                
                const deltaX = e.offsetX - this.lastMouseX;
                const canvas = document.getElementById('waveformChart');
                const timePerPixel = (this.waveformData.length / this.waveformSampleRate) / (canvas.width * this.zoomLevel);
                
                // Ïä§ÌÅ¨Î°§ Ïò§ÌîÑÏÖã ÏóÖÎç∞Ïù¥Ìä∏
                this.scrollOffset -= deltaX * timePerPixel;
                
                // Î≤îÏúÑ Ï†úÌïú
                const maxDuration = this.waveformData.length / this.waveformSampleRate;
                const viewDuration = maxDuration / this.zoomLevel;
                this.scrollOffset = Math.max(0, Math.min(maxDuration - viewDuration, this.scrollOffset));
                
                this.lastMouseX = e.offsetX;
                this.redrawWaveform();
            }
            
            onWaveformMouseUp(e) {
                if (this.manualMode) {
                    if (this.manualSelecting) {
                        this.manualSelecting = false;
                        this.processManualSelection();
                    }
                    e.target.style.cursor = 'crosshair';
                    return;
                }
                this.isDragging = false;
                e.target.style.cursor = 'grab';
            }
            
            onWaveformWheel(e) {
                e.preventDefault();
                if (!this.waveformData) return;
                
                const canvas = document.getElementById('waveformChart');
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                
                // Ï§å Î†àÎ≤® Ï°∞Ï†ï
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoomLevel = Math.max(1, Math.min(1000, this.zoomLevel * zoomFactor));
                
                // ÎßàÏö∞Ïä§ ÏúÑÏπòÎ•º Ï§ëÏã¨ÏúºÎ°ú Ï§å
                const maxDuration = this.waveformData.length / this.waveformSampleRate;
                const viewDuration = maxDuration / this.zoomLevel;
                const mouseTimeRatio = mouseX / canvas.width;
                const mouseTime = this.scrollOffset + viewDuration * mouseTimeRatio;
                
                this.zoomLevel = newZoomLevel;
                const newViewDuration = maxDuration / this.zoomLevel;
                this.scrollOffset = mouseTime - newViewDuration * mouseTimeRatio;
                
                // Î≤îÏúÑ Ï†úÌïú
                this.scrollOffset = Math.max(0, Math.min(maxDuration - newViewDuration, this.scrollOffset));
                
                this.redrawWaveform();
            }
          
onWaveformTouchStart(e) {
    if (!this.waveformData) return;
    
    if (e.touches.length === 1) {
        // Ìïú ÏÜêÍ∞ÄÎùΩ: Ï£ºÍ∏∞Ïûê Î™®Îìú ÎòêÎäî ÎìúÎûòÍ∑∏ Ïä§ÌÅ¨Î°§
        const canvas = document.getElementById('waveformChart');
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        
        if (this.manualMode) {
            // Ï£ºÍ∏∞Ïûê Î™®Îìú: ÌÑ∞Ïπò ÎìúÎûòÍ∑∏ ÏãúÏûë
            this.manualSelecting = true;
            this.manualSelStartX = touch.clientX - rect.left;
            this.manualSelEndX = touch.clientX - rect.left;
            this.redrawWaveform();
        } else {
            // ÏùºÎ∞ò ÎìúÎûòÍ∑∏ Ïä§ÌÅ¨Î°§
            this.isDragging = true;
            this.lastMouseX = touch.clientX - rect.left;
            canvas.style.cursor = 'grabbing';
        }
        e.preventDefault();
    } else if (e.touches.length === 2) {
        // Îëê ÏÜêÍ∞ÄÎùΩ: ÌïÄÏπò Ï§å
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        this._pinchDist = Math.hypot(dx, dy);

        const canvas = document.getElementById('waveformChart');
        const rect = canvas.getBoundingClientRect();
        const cx = (e.touches[0].clientX + e.touches[1].clientX) * 0.5 - rect.left;
        this._pinchCenterX = Math.max(0, Math.min(canvas.width, cx));
        e.preventDefault();
    }
}

onWaveformTouchMove(e) {
    if (!this.waveformData) return;
    
    if (e.touches.length === 1) {
        // Ìïú ÏÜêÍ∞ÄÎùΩ: Ï£ºÍ∏∞Ïûê Î™®Îìú ÎìúÎûòÍ∑∏ ÎòêÎäî ÏùºÎ∞ò Ïä§ÌÅ¨Î°§
        const canvas = document.getElementById('waveformChart');
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        
        if (this.manualMode && this.manualSelecting) {
            // Ï£ºÍ∏∞Ïûê Î™®Îìú: ÎìúÎûòÍ∑∏ ÏÑ†ÌÉù
            this.manualSelEndX = Math.max(0, Math.min(canvas.width, touch.clientX - rect.left));
            this.redrawWaveform();
        } else if (this.isDragging) {
            // ÏùºÎ∞ò ÎìúÎûòÍ∑∏ Ïä§ÌÅ¨Î°§
            const deltaX = (touch.clientX - rect.left) - this.lastMouseX;
            const timePerPixel = (this.waveformData.length / this.waveformSampleRate) / (canvas.width * this.zoomLevel);
            
            this.scrollOffset -= deltaX * timePerPixel;
            
            const maxDuration = this.waveformData.length / this.waveformSampleRate;
            const viewDuration = maxDuration / this.zoomLevel;
            this.scrollOffset = Math.max(0, Math.min(maxDuration - viewDuration, this.scrollOffset));
            
            this.lastMouseX = touch.clientX - rect.left;
            this.redrawWaveform();
        }
        e.preventDefault();
    } else if (e.touches.length === 2 && this._pinchDist) {
        // Îëê ÏÜêÍ∞ÄÎùΩ: ÌïÄÏπò Ï§å
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.hypot(dx, dy);

        const canvas = document.getElementById('waveformChart');
        const maxDuration = this.waveformData.length / this.waveformSampleRate;

        const zoomFactor = dist / this._pinchDist;
        this._pinchDist = dist;

        const newZoom = Math.max(1, Math.min(1000, this.zoomLevel * zoomFactor));

        const mouseTimeRatio = this._pinchCenterX / canvas.width;
        const viewDuration   = maxDuration / this.zoomLevel;
        const anchorTime     = this.scrollOffset + viewDuration * mouseTimeRatio;

        this.zoomLevel = newZoom;

        const newViewDuration = maxDuration / this.zoomLevel;
        this.scrollOffset = anchorTime - newViewDuration * mouseTimeRatio;

        this.scrollOffset = Math.max(0, Math.min(maxDuration - newViewDuration, this.scrollOffset));

        this.redrawWaveform();
        e.preventDefault();
    }
}

onWaveformTouchEnd(e) {
    if (e.touches.length < 2) {
        this._pinchDist = null;
    }
    if (e.touches.length === 0) {
        // Î™®Îì† ÌÑ∞ÏπòÍ∞Ä ÎÅùÎÇ®: ÎìúÎûòÍ∑∏ ÏÉÅÌÉú Ìï¥Ï†ú
        this.isDragging = false;
        const canvas = document.getElementById('waveformChart');
        if (canvas) canvas.style.cursor = 'grab';
        
        // Ï£ºÍ∏∞Ïûê Î™®ÎìúÏóêÏÑú ÎìúÎûòÍ∑∏Í∞Ä ÎÅùÎÇòÎ©¥ ÏûêÎèô Ï≤òÎ¶¨
        if (this.manualMode && this.manualSelecting) {
            this.processManualSelection();
            this.manualSelecting = false;
        }
    }
}

onWaveformPanStart(e) {
    if (!this.waveformData) return;
    if (e.touches.length === 1) {
        this._panLastX = e.touches[0].clientX;
    }
}

onWaveformPanMove(e) {
    if (!this.waveformData) return;
    if (e.touches.length === 1 && this._panLastX != null) {
        const canvas = document.getElementById('waveformChart');
        const maxDuration = this.waveformData.length / this.waveformSampleRate;
        const viewDuration = maxDuration / this.zoomLevel;

        // Ïù¥ÎèôÎüâ(px ‚Üí ÏãúÍ∞Ñ Îã®ÏúÑÎ°ú ÌôòÏÇ∞)
        const dx = e.touches[0].clientX - this._panLastX;
        const dt = -dx / canvas.width * viewDuration;

        this.scrollOffset = Math.max(0, Math.min(maxDuration - viewDuration, this.scrollOffset + dt));
        this._panLastX = e.touches[0].clientX;

        this.redrawWaveform();
        e.preventDefault();
    }
}

onWaveformPanEnd(e) {
    if (e.touches.length === 0) {
        this._panLastX = null;
    }
}
 
            resetWaveformView() {
                this.scrollOffset = 0;
                this.zoomLevel = 1;
                this.redrawWaveform();
            }
            
            redrawWaveform() {
                if (!this.waveformData) return;
                this.drawScrollableWaveform(this.waveformData, this.waveformSampleRate);
            }

            processManualSelection() {
                try {
                    if (this.manualSelStartX == null || this.manualSelEndX == null) return;
                    const canvas = document.getElementById('waveformChart');
                    const width = canvas.width;
                    const sx = Math.min(this.manualSelStartX, this.manualSelEndX);
                    const ex = Math.max(this.manualSelStartX, this.manualSelEndX);
                    if (ex - sx < 4) return;

                    const totalDuration = this.waveformData.length / this.waveformSampleRate;
                    const viewDuration = totalDuration / this.zoomLevel;
                    const t1 = this.scrollOffset + (sx / width) * viewDuration;
                    const t2 = this.scrollOffset + (ex / width) * viewDuration;
                    const startSample = Math.max(0, Math.floor(t1 * this.waveformSampleRate));
                    const endSample = Math.min(this.waveformData.length, Math.ceil(t2 * this.waveformSampleRate));
                    const segment = this.waveformData.slice(startSample, endSample);
                    if (segment.length < 32) return;

                    // ÌèâÍ∑† Ï†úÍ±∞(DC Ïò§ÌîÑÏÖã Ï†úÍ±∞) ÌõÑ ÏÉÅÏäπ ÏòÅÏ†êÍµêÏ∞®Îßå Ïπ¥Ïö¥Ìä∏
                    let mean = 0;
                    for (let i=0;i<segment.length;i++) mean += segment[i];
                    mean /= segment.length;
                    const seg = segment.map(v => v - mean);

                    // f0 Ï∂îÏ†ïÍ∞íÏúºÎ°ú ÏµúÏÜå Í∞ÑÍ≤©(Î∂àÏùëÍ∏∞) ÏÑ§Ï†ï
                    let f0Guess = this.lastDominantFreq || 0;
                    if (!Number.isFinite(f0Guess) || f0Guess <= 0) {
                        let zc=0; for (let i=1;i<seg.length;i++){ const a=seg[i-1], b=seg[i]; if ((a<0 && b>=0) || (a>=0 && b<0)) zc++; }
                        f0Guess = (zc/2) * (this.waveformSampleRate / seg.length);
                    }
                    const minInt = Math.max(1, Math.floor(this.waveformSampleRate / Math.max(80, f0Guess*1.8)));

                    const crossings = [];
                    let lastIdx = -1e9;
                    for (let i=1;i<seg.length;i++){
                        const a = seg[i-1], b = seg[i];
                        // ÏÉÅÏäπ ÏòÅÏ†êÍµêÏ∞®Îßå
                        if (a < 0 && b >= 0) {
                            if (i - lastIdx >= minInt) {
                                crossings.push(i);
                                lastIdx = i;
                            }
                        }
                    }

                    // Î°úÏª¨ FFTÎ°ú Î≥¥Ï°∞ f0 Í≥ÑÏÇ∞(Ï†ïÎ∞Ä Î≥¥Í∞Ñ Ìè¨Ìï®)
                    const localFftSize = Math.min(8192, 1<<Math.ceil(Math.log2(Math.min(seg.length, 4096))));
                    const win = new Array(localFftSize).fill(0);
                    const copyN = Math.min(localFftSize, seg.length);
                    for (let i=0;i<copyN;i++) {
                        const w = 0.5*(1-Math.cos(2*Math.PI*i/(copyN-1)));
                        win[i] = seg[i]*w;
                    }
                    const dft = this.computeDFT(win);
                    const mags = [];
                    for (let k=0;k<dft.length;k++) mags.push(Math.hypot(dft[k].real, dft[k].imag));
                    let kPeak = 1; let magPeak = 0;
                    for (let k=1;k<mags.length;k++){ if (mags[k]>magPeak){ magPeak=mags[k]; kPeak=k; } }
                    let fLocalFFT = (kPeak * this.waveformSampleRate) / (2 * dft.length);
                    if (kPeak>0 && kPeak<mags.length-1){
                        const y1 = mags[kPeak-1], y2 = mags[kPeak], y3 = mags[kPeak+1];
                        const denom = (y1 - 2*y2 + y3);
                        const xoff = Math.abs(denom) < 1e-12 ? 0 : 0.5*(y1 - y3)/denom;
                        const binWidth = this.waveformSampleRate / (2 * dft.length);
                        fLocalFFT = Math.max(0, (kPeak + xoff) * binWidth);
                    }

                    // Zero-crossing: ÌèâÍ∑† Ï£ºÍ∏∞ Í∏∞Î∞ò(Ïù∏Ï†ë ÍµêÏ∞® Í∞Ñ ÌèâÍ∑†)ÏúºÎ°ú Í∞úÏÑ†
                    let fZero = 0;
                    if (crossings.length >= 3) {
                        let sumInt = 0; let cnt = 0;
                        for (let i=1;i<crossings.length;i++){ sumInt += (crossings[i]-crossings[i-1]); cnt++; }
                        const meanInt = sumInt / Math.max(1,cnt);
                        const T = meanInt / this.waveformSampleRate;
                        fZero = T>0 ? 1/T : 0;
                    } else {
                        const cycles = crossings.length>1 ? (crossings.length-1) : 0;
                        const dt = (endSample - startSample) / this.waveformSampleRate;
                        fZero = (dt>0 && cycles>0) ? cycles/dt : 0;
                    }

                    // ÏûêÍ∏∞ÏÉÅÍ¥Ä Í∏∞Î∞ò Ï£ºÍ∏∞ Ï∂îÏ†ï(Íµ≠ÏÜå ÏµúÎåÄ)
                    let fAC = 0;
                    const maxLag = Math.min(seg.length-3, Math.floor(this.waveformSampleRate/Math.max(50, (f0Guess||200))))
                    const minLag = Math.max(2, Math.floor(this.waveformSampleRate/Math.max(6000, (f0Guess||200)*2)));
                    if (maxLag > minLag) {
                        let bestLag = minLag; let bestVal = -1e9;
                        for (let lag=minLag; lag<=maxLag; lag++){
                            let s=0; let n=seg.length-lag;
                            for (let i=0;i<n;i++) s += seg[i]*seg[i+lag];
                            if (s > bestVal){ bestVal=s; bestLag=lag; }
                        }
                        const T = bestLag / this.waveformSampleRate;
                        fAC = T>0 ? 1/T : 0;
                    }

                    // ÏÑ∏ Ï∂îÏ†ïÏπò Í≤∞Ìï©: Ï§ëÍ∞ÑÍ∞í ÏÇ¨Ïö© ÌõÑ Ï†ÑÏó≠ f0Ïùò ¬±20%Î°ú ÌÅ¥Îû®ÌîÑ
                    const candidates = [fZero, fLocalFFT, fAC].filter(x => Number.isFinite(x) && x>0);
                    let fEst = 0;
                    if (candidates.length>0){
                        candidates.sort((a,b)=>a-b);
                        fEst = candidates[Math.floor(candidates.length/2)];
                    }
                    const globalF0 = this.lastDominantFreq;
                    if (Number.isFinite(globalF0) && globalF0>0) {
                        const low = globalF0*0.85, high = globalF0*1.15;
                        if (fEst>0) fEst = Math.min(high, Math.max(low, fEst));
                        else fEst = globalF0; // Ìè¥Î∞±
                    }

                    this.manualAutoResult = { f: Number.isFinite(fEst)?fEst:0, startSample, endSample, crossings: crossings.map(i=>startSample+i), fZero, fLocalFFT, fAC };
                    this.updateManualInfo();
                    this.redrawWaveform();
                } catch (err) {
                    console.error('ÏàòÎèô Íµ¨Í∞Ñ Ï£ºÌååÏàò Í≥ÑÏÇ∞ Ïò§Î•ò:', err);
                }
            }

            toggleManualMode() {
                this.manualMode = !this.manualMode;
                const btn = document.getElementById('manualToggleBtn');
                if (btn) btn.classList.toggle('active', this.manualMode);
                const info = document.getElementById('manualInfo');
                if (info) info.textContent = this.manualMode ? 'ÎìúÎûòÍ∑∏Î°ú Íµ¨Í∞Ñ ÏÑ†ÌÉù ÎòêÎäî ÌîºÌÅ¨ ÌÅ¥Î¶≠' : '‚Äî';
                const canvas = document.getElementById('waveformChart');
                if (canvas) canvas.style.cursor = this.manualMode ? 'crosshair' : 'grab';
                if (!this.manualMode) {
                    this.manualClicks = [];
                    this.manualSelStartX = this.manualSelEndX = null;
                    this.manualAutoResult = null;
                    this.redrawWaveform();
                }
            }

            manualUndo() {
                if (this.manualClicks.length > 0) {
                    this.manualClicks.pop();
                    this.redrawWaveform();
                    this.updateManualInfo();
                }
            }

            manualReset() {
                this.manualClicks = [];
                this.redrawWaveform();
                this.updateManualInfo();
            }

            handleManualClick(e) {
                if (!this.waveformData) return;
                const canvas = document.getElementById('waveformChart');
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                // ÎìúÎûòÍ∑∏ ÏÑ†ÌÉù ÏãúÏûë
                this.manualSelecting = true;
                this.manualSelStartX = Math.max(0, Math.min(canvas.width, x));
                this.manualSelEndX = this.manualSelStartX;
                const totalDuration = this.waveformData.length / this.waveformSampleRate;
                const viewDuration = totalDuration / this.zoomLevel;
                const t = this.scrollOffset + (x / canvas.width) * viewDuration;
                let sampleIndex = Math.max(0, Math.min(this.waveformData.length - 1, Math.round(t * this.waveformSampleRate)));

                // Ïä§ÎÉÖ-Ìà¨-ÌîºÌÅ¨: Í∑ºÏ≤ò ÏµúÎåÄÍ∞íÏúºÎ°ú Ïù¥Îèô(¬±5ms)
                if (this.manualSnapToPeak) {
                    const radius = Math.max(1, Math.floor(0.005 * this.waveformSampleRate));
                    let bestIdx = sampleIndex;
                    let bestVal = Math.abs(this.waveformData[sampleIndex] || 0);
                    for (let i = Math.max(0, sampleIndex - radius); i <= Math.min(this.waveformData.length - 1, sampleIndex + radius); i++) {
                        const v = Math.abs(this.waveformData[i] || 0);
                        if (v > bestVal) { bestVal = v; bestIdx = i; }
                    }
                    sampleIndex = bestIdx;
                }

                this.manualClicks.push(sampleIndex);
                this.redrawWaveform();
                this.updateManualInfo();
            }

            updateManualInfo() {
                const info = document.getElementById('manualInfo');
                if (!info) return;
                if (this.manualAutoResult && Number.isFinite(this.manualAutoResult.f)) {
                    const dt = (this.manualAutoResult.endSample - this.manualAutoResult.startSample) / this.waveformSampleRate;
                    const N = (this.manualAutoResult.crossings || []).length;
                    info.textContent = `Íµ¨Í∞Ñ Œît=${dt.toFixed(3)}s | ÍµêÏ∞® ${N}Í∞ú ‚Üí f‚âà${this.manualAutoResult.f.toFixed(1)}Hz`;
                    return;
                }
                if (this.manualClicks.length < 2) { info.textContent = `ÌÅ¥Î¶≠: ${this.manualClicks.length}`; return; }
                const first = this.manualClicks[0];
                const last = this.manualClicks[this.manualClicks.length - 1];
                const dt = Math.max(0, (last - first) / this.waveformSampleRate);
                const cycles = Math.max(0, this.manualClicks.length - 1);
                const f = dt > 0 && cycles > 0 ? cycles / dt : 0;
                info.textContent = `ÌÅ¥Î¶≠: ${this.manualClicks.length} | Œît=${dt.toFixed(3)}s | f‚âà${f.toFixed(1)}Hz`;
            }
            
            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.add('dragover');
            }
            
            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
            }
            
            handleDrop(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.processFile(files[0]);
                }
            }
            
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.processFile(file);
                }
            }
            
            async processFile(file) {
                if (!file.type.startsWith('audio/')) {
                    this.updateStatus('Ïò§ÎîîÏò§ ÌååÏùºÎßå ÏóÖÎ°úÎìú Í∞ÄÎä•Ìï©ÎãàÎã§.', 'error');
                    return;
                }
                
                if (file.size > 10 * 1024 * 1024) {
                    this.updateStatus('ÌååÏùº ÌÅ¨Í∏∞Í∞Ä 10MBÎ•º Ï¥àÍ≥ºÌï©ÎãàÎã§.', 'error');
                    return;
                }
                
                this.updateStatus('ÌååÏùºÏùÑ Î∂ÑÏÑùÌïòÍ≥† ÏûàÏäµÎãàÎã§...', 'analyzing');
                
                try {
                    const audioBuffer = await this.loadAudioFile(file);
                    await this.analyzeAudioBuffer(audioBuffer);
                } catch (error) {
                    console.error('ÌååÏùº Ï≤òÎ¶¨ Ïò§Î•ò:', error);
                    this.updateStatus('ÌååÏùº Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', 'error');
                }
            }
            
            async loadAudioFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            const audioBuffer = await audioContext.decodeAudioData(e.target.result);
                            resolve(audioBuffer);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }
            
            async analyzeAudioBuffer(audioBuffer) {
                try {
                    console.log('Ïò§ÎîîÏò§ Î≤ÑÌçº Î∂ÑÏÑù ÏãúÏûë...');
                    
                    // Ïò§ÎîîÏò§ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
                    const channelData = audioBuffer.getChannelData(0);
                    const sampleRate = audioBuffer.sampleRate;
                    const duration = audioBuffer.duration;
                    
                    console.log('Ïò§ÎîîÏò§ Ï†ïÎ≥¥:', {
                        samples: channelData.length,
                        sampleRate,
                        duration
                    });
                    
                    // Í∞ÑÎã®Ìïú Î∂ÑÏÑùÎßå ÏàòÌñâ (Ïä§ÌÉù Ïò§Î≤ÑÌîåÎ°úÏö∞ Î∞©ÏßÄ)
                    const analysis = this.performSimpleAnalysis(channelData, sampleRate);
                    
                    // Í≤∞Í≥º ÌëúÏãú
                    this.displaySimpleResults(analysis, channelData, sampleRate);
                    
                    // Í∞úÏÑ†Îêú Ï∞®Ìä∏ Í∑∏Î¶¨Í∏∞
                    setTimeout(() => {
                        // ÌååÌòï Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• (Ïä§ÌÅ¨Î°§Ïö©)
                        this.waveformData = channelData;
                        this.waveformSampleRate = sampleRate;
                        this.scrollOffset = 0;
                        this.zoomLevel = 1;
                        
                        this.drawScrollableWaveform(channelData, sampleRate);
                        this.drawRealSpectrum(analysis.spectrum, analysis.freqBins || [], sampleRate);
                    }, 100);
                    
                    document.getElementById('resultsSection').classList.remove('hidden');
                    this.updateStatus('Î∂ÑÏÑùÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!', 'complete');
                    


                } catch (error) {
                    console.error('Î∂ÑÏÑù Ï§ë Ïò§Î•ò:', error);
                    this.updateStatus(`Î∂ÑÏÑù Ï§ë Ïò§Î•ò: ${error.message}`, 'error');
                }
            }

            
calculateQFactor(powerSpectrum, freqBins, dominantFreq) {
    try {
        console.log('Q-Factor Í≥ÑÏÇ∞ ÏãúÏûë:', dominantFreq);
        
        // Ï£ºÏöî ÌîºÌÅ¨ Ïù∏Îç±Ïä§ Ï∞æÍ∏∞
        let peakIndex = -1;
        let peakMagnitude = 0;
        
                // Ï£ºÏöî ÌîºÌÅ¨ Ïù∏Îç±Ïä§ Ï∞æÍ∏∞ (Í≥†Ï†ïÌè≠ ÏÇ¨Ïö© Í∏àÏßÄ: dominantFreqÏóê Í∞ÄÏû• Í∞ÄÍπåÏö¥ Îπà ÏÑ†ÌÉù)
peakIndex = 0;                                   // ‚Üê 'let' ÏÇ≠Ï†ú (Í∏∞Ï°¥ ÏÑ†Ïñ∏ Ïû¨ÏÇ¨Ïö©)
peakMagnitude = powerSpectrum[0] || 0;           // ‚Üê 'let' ÏÇ≠Ï†ú (Í∏∞Ï°¥ ÏÑ†Ïñ∏ Ïû¨ÏÇ¨Ïö©)
let minDiff = Infinity;
for (let i = 0; i < powerSpectrum.length && i < freqBins.length; i++) {
    const d = Math.abs(freqBins[i] - dominantFreq);
    if (d < minDiff) {
        minDiff = d;
        peakIndex = i;
        peakMagnitude = powerSpectrum[i];
    }
}
console.log('ÌîºÌÅ¨ Ïù∏Îç±Ïä§:', peakIndex, 'ÌîºÌÅ¨ ÌÅ¨Í∏∞:', peakMagnitude);
if (peakIndex === -1) return NaN;



// Ìè¨Î¨ºÏÑ† Î≥¥Í∞Ñ Ìï®Ïàò
function parabolicInterpolation(y1, y2, y3) {
    const a = (y1 - 2*y2 + y3) / 2;
    const b = (y3 - y1) / 2;
    if (Math.abs(a) < 1e-10) return { xOffset: 0, yPeak: y2 };
    const xOffset = -b / (2*a);
    const yPeak = y2 - b*b/(4*a);
    return { xOffset, yPeak };
}

// ÌîºÌÅ¨ Î≥¥Í∞Ñ Ï†ÅÏö©
let correctedFreq = dominantFreq;
let correctedMagnitude = peakMagnitude;

if (peakIndex > 0 && peakIndex < powerSpectrum.length - 1) {
    const interp = parabolicInterpolation(
        powerSpectrum[peakIndex-1],
        powerSpectrum[peakIndex], 
        powerSpectrum[peakIndex+1]
    );
    
    const binWidth = freqBins.length > 1 ? (freqBins[1] - freqBins[0]) : 10;
    correctedFreq = freqBins[peakIndex] + interp.xOffset * binWidth;
    correctedMagnitude = Math.max(0, interp.yPeak);

    
    console.log('Î≥¥Í∞Ñ Ï†Ñ Ï£ºÌååÏàò:', freqBins[peakIndex]);
    console.log('Î≥¥Í∞Ñ ÌõÑ Ï£ºÌååÏàò:', correctedFreq);
    console.log('Î≥¥Í∞Ñ Ï†Ñ ÌÅ¨Í∏∞:', peakMagnitude);
    console.log('Î≥¥Í∞Ñ ÌõÑ ÌÅ¨Í∏∞:', correctedMagnitude);
}
// Ï†ïÌôïÌïú -3dB ÏßÄÏ†ê Ï∞æÍ∏∞ Ìï®Ïàò (ÌååÏõå Í∏∞Ï§Ä, ÎÖ∏Ïù¥Ï¶à Î≥¥Ï†ï Ìè¨Ìï®)
function findExact3dBPoint(spectrum, freqBins, peakIndex, threshold, direction) {
    let idx = peakIndex;
    const binWidth = freqBins.length > 1 ? (freqBins[1] - freqBins[0]) : 10;
    
    while (idx > 0 && idx < spectrum.length - 1) {
        idx += direction;
        if (spectrum[idx] <= threshold) {
            if (idx - direction >= 0 && idx - direction < spectrum.length) {
                // ÏÑ†Ìòï Î≥¥Í∞ÑÏúºÎ°ú Ï†ïÌôïÌïú ÏúÑÏπò Ï∞æÍ∏∞
                const y1 = spectrum[idx - direction];
                const y2 = spectrum[idx];
                const f1 = freqBins[idx - direction] || (freqBins[0] + (idx - direction) * binWidth);
                const f2 = freqBins[idx] || (freqBins[0] + idx * binWidth);
                
                if (Math.abs(y1 - y2) > 1e-10) {
                    const ratio = (threshold - y2) / (y1 - y2);
                    return f2 + ratio * (f1 - f2);
                }
            }
            return freqBins[idx] || (freqBins[0] + idx * binWidth);
        }
    }
    return freqBins[idx] || (freqBins[0] + idx * binWidth);
}

// Î≥¥Ï†ïÎêú Í∞íÏúºÎ°ú dominantFreq, peakMagnitude ÏóÖÎç∞Ïù¥Ìä∏
dominantFreq = correctedFreq;
peakMagnitude = correctedMagnitude;        
 this.correctedDominantFreq = correctedFreq;


        // ÎÖ∏Ïù¥Ï¶à Î∞îÎã• Ï∂îÏ†ï (Ï§ëÏïôÍ∞í Í∏∞Î∞ò, ÏÉÅÏúÑ 10% Ï†úÏô∏)
const sortedSpec = [...powerSpectrum].sort((a,b)=>a-b);
const cutIdx = Math.floor(sortedSpec.length * 0.9);
const noiseCandidates = sortedSpec.slice(0, Math.max(1, cutIdx));
const noiseMedian = noiseCandidates[Math.floor(noiseCandidates.length/2)] || 0;

// Power Í∏∞Î∞ò half-power ÏûÑÍ≥ÑÏπò(ÎÖ∏Ïù¥Ï¶à Î≥¥Ï†ï): P_thr = Pn + 0.5*(Pp - Pn)
const peakPower = peakMagnitude * peakMagnitude;
const noisePower = noiseMedian * noiseMedian;
const targetPower = noisePower + 0.5 * Math.max(0, peakPower - noisePower);
const halfPowerLevel = Math.sqrt(Math.max(targetPower, 0));
        
        let leftIndex = peakIndex;
        let rightIndex = peakIndex;
        
        // ÏôºÏ™Ω -3dB ÏßÄÏ†ê (ÏÑ†Ìòï Î≥¥Í∞Ñ Ï†ÅÏö©)
        while (leftIndex > 0 && powerSpectrum[leftIndex] > halfPowerLevel) {
            leftIndex--;
        }
        
        // Ïò§Î•∏Ï™Ω -3dB ÏßÄÏ†ê (ÏÑ†Ìòï Î≥¥Í∞Ñ Ï†ÅÏö©)
        while (rightIndex < powerSpectrum.length - 1 && powerSpectrum[rightIndex] > halfPowerLevel) {
            rightIndex++;
        }
        
       // Ï†ïÍµêÌïú -3dB ÏßÄÏ†ê ÌÉêÏßÄ
const f1 = findExact3dBPoint(powerSpectrum, freqBins, peakIndex, halfPowerLevel, -1);
const f2 = findExact3dBPoint(powerSpectrum, freqBins, peakIndex, halfPowerLevel, 1);

console.log('Ï†ïÍµêÌïú f1:', f1, 'f2:', f2);
        
       
        
       let bandwidth = f2 - f1;
// Ï∞Ω/Î∂ÑÌï¥Îä• ÌïúÍ≥Ñ Î≥¥Ï†ï: HannÏùò FWHM ‚âà 1.5 bins ÌïòÌïú
const binWidth = freqBins.length > 1 ? (freqBins[1] - freqBins[0]) : 10;
const minBandwidth = 1.5 * binWidth;
bandwidth = Math.max(bandwidth, minBandwidth);
console.log('f1:', f1, 'f2:', f2, 'bandwidth:', bandwidth);
if (bandwidth <= 0) return NaN;

const qFactor = dominantFreq / bandwidth;
console.log('Í≥ÑÏÇ∞Îêú Q-Factor:', qFactor);
return qFactor;

        
   } catch (error) {
    console.error('Q-Factor Í≥ÑÏÇ∞ Ïò§Î•ò:', error);
    return NaN;
}
}

calculateHarmonicRatio(powerSpectrum, freqBins, dominantFreq) {
    try {
        console.log('ÌïòÎ™®Îãâ Í≥ÑÏÇ∞ ÏãúÏûë:', dominantFreq);
        if (powerSpectrum.length === 0 || freqBins.length === 0) return 50.0;
        
        // Îπà ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ (Ï†ÅÏùëÏ†Å Î≤îÏúÑÎ•º ÏúÑÌï¥)
        const binWidth = freqBins.length > 1 ? (freqBins[1] - freqBins[0]) : 10;
        const searchRange = Math.max(binWidth * 5, 50); // Îçî ÎÑìÏùÄ Î≤îÏúÑ
        
        // ÏóêÎÑàÏßÄ Ï†úÍ≥± ÎØ∏Î¶¨ Í≥ÑÏÇ∞ (Ìö®Ïú®ÏÑ±)
        const energySquared = powerSpectrum.map(val => val * val);
        
        let fundamentalEnergy = 0;
        let harmonicEnergy = 0;
        let totalEnergy = 0;
        
        // Ï†ÑÏ≤¥ ÏóêÎÑàÏßÄ Í≥ÑÏÇ∞
        for (let i = 0; i < energySquared.length; i++) {
            totalEnergy += energySquared[i];
        }
        
        if (totalEnergy === 0) return 50.0;
        
        // ÏÇ¨Ïö©Îêú Îπà Ï∂îÏ†Å (Ï§ëÎ≥µ Î∞©ÏßÄ)
        const usedBins = new Set();
        
        // Í∏∞Î≥∏ Ï£ºÌååÏàò ÏóêÎÑàÏßÄ
        for (let i = 0; i < freqBins.length; i++) {
            if (Math.abs(freqBins[i] - dominantFreq) <= searchRange) {
                fundamentalEnergy += energySquared[i];
                usedBins.add(i);
            }
        }
        
        // ÌïòÎ™®Îãâ ÏóêÎÑàÏßÄ (2Ï∞®~5Ï∞®, Ï§ëÎ≥µ Î∞©ÏßÄ)
        for (let harmonic = 2; harmonic <= 5; harmonic++) {
            const harmonicFreq = dominantFreq * harmonic;
            
            for (let i = 0; i < freqBins.length; i++) {
                if (!usedBins.has(i) && Math.abs(freqBins[i] - harmonicFreq) <= searchRange) {
                    harmonicEnergy += energySquared[i];
                    usedBins.add(i); // Ï§ëÎ≥µ Î∞©ÏßÄ
                }
            }
        }
        
       // ÌïòÎ™®Îãâ ÎπÑÏú® Í≥ÑÏÇ∞
        console.log('Í∏∞Î≥∏Ìåå ÏóêÎÑàÏßÄ:', fundamentalEnergy, 'ÌïòÎ™®Îãâ ÏóêÎÑàÏßÄ:', harmonicEnergy, 'Ï†ÑÏ≤¥ ÏóêÎÑàÏßÄ:', totalEnergy);
        const harmonicRatio = (harmonicEnergy / totalEnergy) * 100;
        console.log('Í≥ÑÏÇ∞Îêú ÌïòÎ™®Îãâ ÎπÑÏú®:', harmonicRatio);
        return Math.max(0, Math.min(100, harmonicRatio));
        
    } catch (error) {
        console.error('ÌïòÎ™®Îãâ ÎπÑÏú® Í≥ÑÏÇ∞ Ïò§Î•ò:', error);
        return 50.0;
    }
}
            performSimpleAnalysis(channelData, sampleRate) {
                console.log('Í∞ÑÎã®Ìïú Î∂ÑÏÑù ÏãúÏûë...');
                
                try {
                    // 1. Í∏∞Î≥∏ ÌÜµÍ≥Ñ
                    const maxAmplitude = this.safeMax(channelData.map(Math.abs));
                    const rms = this.safeRMS(channelData);
                    
                    // 2. ÌîºÌÅ¨ ÌÉêÏßÄ
                    const peakIdx = this.safeFindMax(channelData);
                    const peakTime = peakIdx / sampleRate;
                    
                    // 3. Ïã§Ï†ú FFTÎ•º ÏÇ¨Ïö©Ìïú Ï£ºÌååÏàò Î∂ÑÏÑù
                    const frequencyAnalysis = this.performFFTAnalysis(channelData, sampleRate);
                    const dominantFreq = frequencyAnalysis.dominantFreq;
                    const spectrum = frequencyAnalysis.spectrum;
                    
                    // 4. Í∞ÑÎã®Ìïú Í∞êÏá† Ï∂îÏ†ï
                    const decayInfo = this.estimateSimpleDecay(channelData, peakIdx, sampleRate);
                    
                    // 5. Ïû¨Ïßà Î∂ÑÎ•ò (Í∞ÑÎã®Ìïú Í∑úÏπô Í∏∞Î∞ò)
                    const material = this.classifyMaterialSimple(dominantFreq, decayInfo.halfLife, maxAmplitude);
                    
                  // ÌïòÏù¥Î∏åÎ¶¨Îìú Q Í≥ÑÏÇ∞: Q_time = œÄ f0 / Œ¥ ÏôÄ Q_spec (FFT Í∏∞Î∞ò)ÏùÑ Í≤∞Ìï©
                  const qTime = (decayInfo && decayInfo.decay > 0 && Number.isFinite(dominantFreq))
                    ? Math.PI * dominantFreq / decayInfo.decay
                    : NaN;
                  const qSpec = frequencyAnalysis.qFactor;
                  const r2 = Number.isFinite(decayInfo.rSquared) ? decayInfo.rSquared : 0;
                  const snrForWeight = maxAmplitude / Math.max(rms, 1e-10);
                  const snrNorm = Math.max(0, Math.min(1, (20 * Math.log10(snrForWeight) + 20) / 40)); // ÏïΩ -20~+20dB ‚Üí 0~1
                  const wTime = Math.max(0, Math.min(1, 0.3 + 0.7 * (0.5 * r2 + 0.5 * snrNorm)));
                  const wSpec = 1 - wTime;
                  let qHybrid = Number.isFinite(qTime) && Number.isFinite(qSpec)
                    ? wTime * qTime + wSpec * qSpec
                    : (Number.isFinite(qTime) ? qTime : qSpec);
                  if (!Number.isFinite(qHybrid) || qHybrid <= 0) qHybrid = NaN;

                  // Q Î¶¨Ïä§ÏºÄÏùºÎßÅ Ìï®Ïàò: 1000‚Üí100, 3000‚Üí300 ÏÑ†Ìòï ÎßµÌïë, ÏßßÏùÄ Í∞êÏá†Ïóê ÎåÄÌïú ÏµúÏÜåÍ∞í Î≥¥Ï†ï
                  const rescaleQ = (q, halfLifeSec) => {
                    if (!Number.isFinite(q) || q <= 0) return NaN;
                    let qPrime = 100 + 0.1 * (q - 1000); // ÏÑ†Ìòï Ïä§ÏºÄÏùº
                    // Í∞êÏá†Í∞Ä Îß§Ïö∞ Îπ†Î•∏ Ïã†Ìò∏Îäî ÎÑàÎ¨¥ ÎÇÆÍ≤å Î≥¥Ïù¥ÏßÄ ÏïäÎèÑÎ°ù ÏµúÏÜå Î≥¥Ï†ï(ÏÑ†ÌÉùÏ†Å)
                    if (Number.isFinite(halfLifeSec) && halfLifeSec <= 2 && qPrime < 120) qPrime = 120;
                    // ÌÅ¥Îû®ÌîÑ
                    if (qPrime < 0) qPrime = 0;
                    if (qPrime > 1000) qPrime = 1000;
                    return qPrime;
                  };

                  const qDisplay = rescaleQ(qHybrid, decayInfo.halfLife);

                  return {
    maxAmplitude,
    rms,
    peakIdx,
    peakTime,
    dominantFreq,
    qFactor: qDisplay,
    qFactorRaw: qHybrid,
    harmonicRatio: frequencyAnalysis.harmonicRatio,
    decayCoeff: decayInfo.decay,
    halfLife: decayInfo.halfLife,
    rSquared: decayInfo.rSquared,  // Ï∂îÍ∞Ä!
    duration: channelData.length / sampleRate,
    material,
    spectrum
};
                    
                } catch (error) {
                    console.error('Í∞ÑÎã®Ìïú Î∂ÑÏÑù Ïò§Î•ò:', error);
                    return this.getDefaultAnalysis();
                }
            }
            
            performFFTAnalysis(channelData, sampleRate) {
                try {
                    console.log('FFT Î∂ÑÏÑù ÏãúÏûë...');
                    
                    // FFT ÌÅ¨Í∏∞ Í≤∞Ï†ï (2Ïùò Í±∞Îì≠Ï†úÍ≥±)
                    let fftSize = 1024;
                    while (fftSize < channelData.length && fftSize < 8192) {
                        fftSize *= 2;
                    }
                    fftSize = Math.min(fftSize, 16384); // ÏµúÎåÄ 16384Î°ú Ï¶ùÍ∞Ä
                    
                    // ÏúàÎèÑÏö∞ Ìï®Ïàò Ï†ÅÏö©Ìï† Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
                    const windowedData = this.applyHannWindow(channelData, fftSize);
                    
                    // FFT Í≥ÑÏÇ∞
                    const fftResult = this.computeFFT(windowedData);
                    
                    // ÌååÏõå Ïä§ÌéôÌä∏Îüº Í≥ÑÏÇ∞
                    const powerSpectrum = this.computePowerSpectrum(fftResult);
                    
                    // Ï£ºÌååÏàò Îπà Í≥ÑÏÇ∞
                    const freqBins = [];
                    for (let i = 0; i < powerSpectrum.length; i++) {
                        freqBins.push((i * sampleRate) / (2 * powerSpectrum.length));
                    }
                    
                    // Ï£ºÏöî Ï£ºÌååÏàò Ï∞æÍ∏∞
                    const dominantFreq = this.findDominantFrequency(powerSpectrum, freqBins);
                    
                    console.log('FFT Î∂ÑÏÑù ÏôÑÎ£å:', {
                        fftSize,
                        dominantFreq,
                        spectrumLength: powerSpectrum.length
                    });
                    
                   // Ï∂îÍ∞Ä Î∂ÑÏÑù ÏàòÌñâ
const qFactor = this.calculateQFactor(powerSpectrum, freqBins, dominantFreq);
const refinedF0 = (this.correctedDominantFreq || dominantFreq);
const harmonicRatio = this.calculateHarmonicRatio(powerSpectrum, freqBins, refinedF0);
this.lastDominantFreq = refinedF0;

return {
    spectrum: powerSpectrum,
    dominantFreq: refinedF0,
    freqBins,
    qFactor,
    harmonicRatio
};
                    
                } catch (error) {
                    console.error('FFT Î∂ÑÏÑù Ïò§Î•ò:', error);
                    // Ìè¥Î∞±: Í∞ÑÎã®Ìïú Ïä§ÌéôÌä∏Îüº
                    return {
                        spectrum: this.createSimpleSpectrum(channelData, 440),
                        dominantFreq: 440,
                        freqBins: []
                    };
                }
            }
            
            applyHannWindow(data, fftSize) {
                // Îç∞Ïù¥ÌÑ∞ÏóêÏÑú Í∞ÄÏû• ÏóêÎÑàÏßÄÍ∞Ä ÎÜíÏùÄ Î∂ÄÎ∂Ñ Ï∞æÍ∏∞
                const windowSize = Math.min(fftSize, data.length);
                let maxEnergy = 0;
                let bestStart = 0;
                
                const hopSize = Math.floor(windowSize / 4);
                for (let start = 0; start <= data.length - windowSize; start += hopSize) {
                    let energy = 0;
                    for (let i = 0; i < windowSize; i++) {
                        energy += data[start + i] * data[start + i];
                    }
                    if (energy > maxEnergy) {
                        maxEnergy = energy;
                        bestStart = start;
                    }
                }
                
                // Ìï¥Îãπ Íµ¨Í∞ÑÏóê Hann ÏúàÎèÑÏö∞ Ï†ÅÏö©
                const windowed = new Array(fftSize).fill(0);
                for (let i = 0; i < windowSize; i++) {
                    const hannValue = 0.5 * (1 - Math.cos(2 * Math.PI * i / (windowSize - 1)));
                    windowed[i] = (data[bestStart + i] || 0) * hannValue;
                }
                
                return windowed;
            }
            
            computeFFT(data) {
                const N = data.length;
                
                // Í∞ÑÎã®Ìïú DFT Íµ¨ÌòÑ (ÏûëÏùÄ ÌÅ¨Í∏∞Ïö©)
                if (N <= 512) {
                    return this.computeDFT(data);
                }
                
                // ÌÅ∞ ÌÅ¨Í∏∞Îäî Í∞ÑÎã®Ìïú FFT
                return this.computeSimpleFFT(data);
            }
            
            computeDFT(data) {
                const N = data.length;
                const result = [];
                
                for (let k = 0; k < N / 2; k++) { // ÎÇòÏù¥ÌÄ¥Ïä§Ìä∏ Ï£ºÌååÏàòÍπåÏßÄÎßå
                    let realSum = 0;
                    let imagSum = 0;
                    
                    for (let n = 0; n < N; n++) {
                        const angle = -2 * Math.PI * k * n / N;
                        realSum += data[n] * Math.cos(angle);
                        imagSum += data[n] * Math.sin(angle);
                    }
                    
                    result.push({ real: realSum, imag: imagSum });
                }
                
                return result;
            }
            
            computeSimpleFFT(data) {
                // Îß§Ïö∞ Í∞ÑÎã®Ìïú FFT (ÍµêÏú°Ïö©)
                const N = data.length;
                if (N <= 1) return [{ real: data[0] || 0, imag: 0 }];
                
                // Ïû¨Í∑Ä ÎåÄÏã† DFT ÏÇ¨Ïö© (ÏïàÏ†ÑÏÑ±)
                return this.computeDFT(data);
            }
            
            computePowerSpectrum(fftResult) {
                const powerSpectrum = [];
                
                for (let i = 0; i < fftResult.length; i++) {
                    const real = fftResult[i].real;
                    const imag = fftResult[i].imag;
                    const magnitude = Math.sqrt(real * real + imag * imag);
                    powerSpectrum.push(magnitude);
                }
                
                // Ï†ïÍ∑úÌôî
                const maxMagnitude = Math.max(...powerSpectrum);
                if (maxMagnitude > 0) {
                    for (let i = 0; i < powerSpectrum.length; i++) {
                        powerSpectrum[i] /= maxMagnitude;
                    }
                }
                
                return powerSpectrum;
            }
            
            findDominantFrequency(powerSpectrum, freqBins) {
                let maxMagnitude = 0;
                let dominantFreq = 0;
                
                // 20Hz ~ 5000Hz Î≤îÏúÑÏóêÏÑú Ï∞æÍ∏∞
                for (let i = 0; i < powerSpectrum.length && i < freqBins.length; i++) {
                    const freq = freqBins[i];
                    if (freq >= 20 && freq <= 5000 && powerSpectrum[i] > maxMagnitude) {
                        maxMagnitude = powerSpectrum[i];
                        dominantFreq = freq;
                    }
                }
                
                return dominantFreq || 440; // Í∏∞Î≥∏Í∞í
            }
            
            createSimpleSpectrum(channelData, dominantFreq) {
                // Ìè¥Î∞±Ïö© Í∞ÑÎã®Ìïú Ïä§ÌéôÌä∏Îüº
                const spectrum = new Array(128).fill(0);
                
                try {
                    const centerBin = Math.floor((dominantFreq / 2000) * spectrum.length);
                    
                    if (centerBin >= 0 && centerBin < spectrum.length) {
                        spectrum[centerBin] = 1.0;
                    }
                    
                    // ÌïòÎ™®ÎãâÏä§
                    for (let harmonic = 2; harmonic <= 5; harmonic++) {
                        const harmonicBin = Math.floor(centerBin * harmonic);
                        if (harmonicBin < spectrum.length) {
                            spectrum[harmonicBin] = 1.0 / harmonic;
                        }
                    }
                    
                    // ÎÖ∏Ïù¥Ï¶à ÌîåÎ°úÏñ¥
                    for (let i = 0; i < spectrum.length; i++) {
                        spectrum[i] += Math.random() * 0.05;
                    }
                    
                    return spectrum;
                    
                } catch (error) {
                    spectrum[32] = 1.0;
                    return spectrum;
                }
            }
            
            safeMax(array) {
                if (!array || array.length === 0) return 0;
                let max = array[0];
                for (let i = 1; i < array.length; i++) {
                    if (array[i] > max) max = array[i];
                }
                return max;
            }
            
            safeRMS(array) {
                if (!array || array.length === 0) return 0;
                let sum = 0;
                for (let i = 0; i < array.length; i++) {
                    sum += array[i] * array[i];
                }
                return Math.sqrt(sum / array.length);
            }
            
            safeFindMax(array) {
                if (!array || array.length === 0) return 0;
                let maxIdx = 0;
                let maxVal = Math.abs(array[0]);
                for (let i = 1; i < array.length; i++) {
                    const val = Math.abs(array[i]);
                    if (val > maxVal) {
                        maxVal = val;
                        maxIdx = i;
                    }
                }
                return maxIdx;
            }
            
            estimateFrequencyZeroCrossing(data, sampleRate) {
                try {
                    let crossings = 0;
                    const maxSamples = Math.min(data.length, 10000); // Ï†úÌïú
                    
                    for (let i = 1; i < maxSamples; i++) {
                        if ((data[i-1] >= 0 && data[i] < 0) || (data[i-1] < 0 && data[i] >= 0)) {
                            crossings++;
                        }
                    }
                    
                    const frequency = (crossings / 2) * (sampleRate / maxSamples);
                    return Math.min(Math.max(frequency, 50), 5000); // 50Hz ~ 5kHz Ï†úÌïú
                } catch (error) {
                    console.error('Ï£ºÌååÏàò Ï∂îÏ†ï Ïò§Î•ò:', error);
                    return 440; // Í∏∞Î≥∏Í∞í
                }
            }
            
            estimateSimpleDecay(data, peakIdx, sampleRate) {
                try {
                    const afterPeak = data.slice(peakIdx);
                    const windowSize = Math.floor(sampleRate * 0.01); // 10ms ÏúàÎèÑÏö∞
                    const numWindows = Math.floor(afterPeak.length / windowSize);
                    if (numWindows < 2) {
                        return { decay: 1.0, halfLife: 1.0, rSquared: 0, envelope: [], timePoints: [], slope: 0, intercept: 0 };
                    }

                    // RMS Í∏∞Î∞ò Ìè¨ÎùΩÏÑ† (Ïä§ÌååÏù¥ÌÅ¨ ÏôÑÌôî)
                    const envelope = [];
                    for (let i = 0; i < numWindows; i++) {
                        const start = i * windowSize;
                        const end = Math.min(start + windowSize, afterPeak.length);
                        let sumSq = 0;
                        const len = Math.max(1, end - start);
                        for (let j = start; j < end; j++) {
                            const v = afterPeak[j];
                            sumSq += v * v;
                        }
                        envelope.push(Math.sqrt(sumSq / len));
                    }

                    // Í∞ÑÎã® Ïù¥ÎèôÌèâÍ∑†ÏúºÎ°ú ÌèâÌôúÌôî
                    const smooth = (arr, k) => {
                        const out = new Array(arr.length).fill(0);
                        const radius = Math.max(1, k | 0);
                        let acc = 0;
                        let cnt = 0;
                        let q = [];
                        for (let i = 0; i < arr.length; i++) {
                            q.push(arr[i]);
                            acc += arr[i];
                            cnt++;
                            if (q.length > radius) { acc -= q.shift(); cnt--; }
                            out[i] = acc / Math.max(1, cnt);
                        }
                        return out;
                    };
                    const smoothed = smooth(envelope, 5);

                    // ÏãúÏûëÏ†ê: ÏµúÎåÄÏπò Ïù¥ÌõÑ Ï∂©Î∂ÑÌûà Í∞êÏá†Í∞Ä ÏãúÏûëÎêòÎäî ÏßÄÏ†ê ÏÑ†ÌÉù
                    const maxVal = Math.max(...smoothed);
                    let startIdx = 0;
                    for (let i = 1; i < smoothed.length - 2; i++) {
                        const slope1 = smoothed[i] - smoothed[i - 1];
                        const slope2 = smoothed[i + 1] - smoothed[i];
                        if (smoothed[i] <= maxVal * 0.9 && slope1 < 0 && slope2 < 0) { startIdx = i; break; }
                    }

                    // ÎÖ∏Ïù¥Ï¶à Î†àÎ≤® Ï∂îÏ†ï: Íº¨Î¶¨ Íµ¨Í∞ÑÏùò Ï§ëÏïôÍ∞í
                    const tailN = Math.max(5, Math.floor(smoothed.length * 0.2));
                    const tail = smoothed.slice(-tailN).map(v => Math.max(v, 1e-12));
                    const tailSorted = [...tail].sort((a, b) => a - b);
                    const noiseLevel = tailSorted[Math.floor(tailSorted.length / 2)] || 1e-12;

                    // Ï¢ÖÎ£åÏ†ê: SNR <= 1.5Í∞Ä Ïó∞ÏÜçÏúºÎ°ú ÎÇòÌÉÄÎÇòÎäî Ï≤´ ÏßÄÏ†ê
                    let endIdx = smoothed.length;
                    let consec = 0;
                    const need = 2;
                    for (let i = startIdx; i < smoothed.length; i++) {
                        const snr = smoothed[i] / noiseLevel;
                        if (snr <= 1.5) { consec++; if (consec >= need) { endIdx = i - need + 1; break; } }
                        else { consec = 0; }
                    }
                    if (endIdx <= startIdx + 2) endIdx = smoothed.length;

                    // ÌöåÍ∑Ä Îç∞Ïù¥ÌÑ∞ Íµ¨ÏÑ±
                    const decayEnv = smoothed.slice(startIdx, endIdx).map(v => Math.max(v, 1e-12));
                    const timePoints = decayEnv.map((_, i) => (i + 0.5) * windowSize / sampleRate);
                    const n = decayEnv.length;
                    if (n < 3) {
                        return { decay: 0, halfLife: 0, rSquared: 0, envelope: smoothed, timePoints, slope: 0, intercept: 0 };
                    }

                    const logEnvelope = decayEnv.map(v => Math.log(v));
                    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                    for (let i = 0; i < n; i++) {
                        const x = timePoints[i];
                        const y = logEnvelope[i];
                        sumX += x; sumY += y; sumXY += x * y; sumX2 += x * x;
                    }
                    const denom = n * sumX2 - sumX * sumX;
                    if (denom === 0) {
                        return { decay: 0, halfLife: 0, rSquared: 0, envelope: smoothed, timePoints, slope: 0, intercept: 0 };
                    }
                    const slope = (n * sumXY - sumX * sumY) / denom;
                    const intercept = (sumY - slope * sumX) / n;
                    const decay = Math.max(0, -slope);
                    const halfLife = Math.log(2) / Math.max(decay, 1e-9);

                    // R¬≤ Í≥ÑÏÇ∞
                    let ssTot = 0, ssRes = 0;
                    const meanY = sumY / n;
                    for (let i = 0; i < n; i++) {
                        const x = timePoints[i];
                        const y = logEnvelope[i];
                        const yhat = slope * x + intercept;
                        ssTot += (y - meanY) * (y - meanY);
                        ssRes += (y - yhat) * (y - yhat);
                    }
                    const rSquared = ssTot > 0 ? Math.max(0, Math.min(1, 1 - ssRes / ssTot)) : 0;

                    return { decay, halfLife, rSquared, envelope: smoothed, timePoints, slope, intercept };
                } catch (error) {
                    console.error('Í∞êÏá† Ï∂îÏ†ï Ïò§Î•ò:', error);
                    return { decay: 1.0, halfLife: 1.0, rSquared: 0, envelope: [], timePoints: [], slope: 0, intercept: 0 };
                }
            }
            
            classifyMaterialSimple(frequency, halfLife, amplitude) {
                try {
                    // Îß§Ïö∞ Í∞ÑÎã®Ìïú Í∑úÏπô Í∏∞Î∞ò Î∂ÑÎ•ò
                    const ampThreshold = 0.1;
                    const freqThreshold = 1000;
                    const decayThreshold = 2.0;
                    
                    if (frequency < 500 && halfLife > decayThreshold) {
                        return { name: 'ÎÇòÎ¨¥', class: 'material-wood', confidence: 75 };
                    } else if (frequency > freqThreshold && halfLife < 1.0) {
                        return { name: 'ÎèÑÏûêÍ∏∞', class: 'material-ceramic', confidence: 70 };
                    } else if (frequency > 600 && halfLife < decayThreshold && amplitude > ampThreshold) {
                        return { name: 'ÏïåÎ£®ÎØ∏ÎäÑ', class: 'material-aluminum', confidence: 80 };
                    } else {
                        return { name: 'Ï≤†', class: 'material-iron', confidence: 65 };
                    }
                } catch (error) {
                    console.error('Î∂ÑÎ•ò Ïò§Î•ò:', error);
                    return { name: 'Ïïå Ïàò ÏóÜÏùå', class: 'material-wood', confidence: 50 };
                }
            }
            
            getDefaultAnalysis() {
                return {
                    maxAmplitude: 0.1,
                    rms: 0.05,
                    peakIdx: 1000,
                    peakTime: 0.5,
                    dominantFreq: 440,
                    decayCoeff: 1.0,
                    halfLife: 1.0,
                    duration: 2.0,
                    material: { name: 'Ïïå Ïàò ÏóÜÏùå', class: 'material-wood', confidence: 50 },
                    spectrum: new Array(100).fill(0.1)
                };
            }
            
drawEnvelopeChart(channelData, peakIdx, sampleRate) {
    try {
        const canvas = document.getElementById('envelopeChart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width || 400;
        canvas.height = rect.height || 200;
        
        const width = canvas.width;
        const height = canvas.height;
        
        // Ï∫îÎ≤ÑÏä§ Ï¥àÍ∏∞Ìôî
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#f8f9fa';
        ctx.fillRect(0, 0, width, height);
        
        // ÌîºÌÅ¨ Ïù¥ÌõÑ Îç∞Ïù¥ÌÑ∞
        const afterPeak = channelData.slice(peakIdx);
        const windowSize = Math.floor(sampleRate * 0.01); // 10ms ÏúàÎèÑÏö∞
       const maxWindows = Math.floor(afterPeak.length / windowSize);

        
        if (maxWindows < 2) return;
        
        // Ìè¨ÎùΩÏÑ† Í≥ÑÏÇ∞
        const envelope = [];
        const timePoints = [];
        
        for (let i = 0; i < maxWindows; i++) {
            const start = i * windowSize;
            const end = Math.min(start + windowSize, afterPeak.length);
            let max = 0;
            
            for (let j = start; j < end; j++) {
                max = Math.max(max, Math.abs(afterPeak[j]));
            }
            
            envelope.push(max);
            timePoints.push((start + windowSize/2) / sampleRate); // ÏúàÎèÑÏö∞ Ï§ëÏïô ÏãúÍ∞Ñ
        }
        
        if (envelope.length === 0) return;
        
        // Ï†ïÍ∑úÌôî
        const maxEnv = Math.max(...envelope);
        const normalizedEnv = envelope.map(val => val / maxEnv);
        
        // Ìè¨ÎùΩÏÑ† Í∑∏Î¶¨Í∏∞ (Ïä§Î¨¥Îî© + Î©¥Ï†Å Ï±ÑÏõÄ)
        // Í∞ÑÎã® Ïä§Î¨¥Îî©: Ïù¥ÎèôÌèâÍ∑† 3Ìè¨Ïù∏Ìä∏
        const smooth = (arr) => {
            const out = arr.slice();
            for (let i=1;i<arr.length-1;i++) out[i] = (arr[i-1]+arr[i]+arr[i+1])/3;
            return out;
        };
        const envSmoothed = smooth(normalizedEnv);
        ctx.strokeStyle = '#e74c3c';
        ctx.fillStyle = 'rgba(231, 76, 60, 0.15)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < envSmoothed.length; i++) {
            const x = (i / (envSmoothed.length - 1)) * (width - 40) + 20;
            const y = height - 30 - (envSmoothed[i] * (height - 60));
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.stroke();
        // Î©¥Ï†Å Ï±ÑÏõÄ
        ctx.lineTo(20 + (width-40), height - 30);
        ctx.lineTo(20, height - 30);
        ctx.closePath();
        ctx.fill();
        
        // Ï∂ï ÎùºÎ≤®
        ctx.fillStyle = '#2c3e50';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        
        // ÏãúÍ∞Ñ Ï∂ï
        const timeLabels = [0, timePoints[Math.floor(timePoints.length/2)], timePoints[timePoints.length-1]];
        const xPositions = [20, width/2, width-20];
        
        for (let i = 0; i < timeLabels.length; i++) {
            ctx.fillText(`${timeLabels[i].toFixed(2)}s`, xPositions[i], height - 5);
        }
        
        // Î≤îÎ°Ä
        ctx.textAlign = 'left';
        ctx.fillStyle = '#e74c3c';
        ctx.fillText('‚Äî Ïã§Ï∏° Ìè¨ÎùΩÏÑ†', 10, 15);
        
    } catch (error) {
        console.error('Ìè¨ÎùΩÏÑ† Ï∞®Ìä∏ Ïò§Î•ò:', error);
    }
}

            displaySimpleResults(analysis, channelData, sampleRate) {
                try {
                    console.log('Í≤∞Í≥º ÌëúÏãú Ï§ë...');
                    
                                 
                    // Ï£ºÌååÏàò Î∂ÑÏÑù Í≤∞Í≥º
                    const f0 = analysis.dominantFreq;
document.getElementById('resonantFreq').textContent = Number.isFinite(f0) ? `${f0.toFixed(1)} Hz` : '‚Äî';

const q = analysis.qFactor;
document.getElementById('qFactor').textContent = (Number.isFinite(q) && q > 0) ? q.toFixed(1) : '‚Äî';

document.getElementById('harmonicRatio').textContent = `${(analysis.harmonicRatio || 60.0).toFixed(1)}%`;
                    
                    // Í∞êÏá† Î∂ÑÏÑù Í≤∞Í≥º
                    document.getElementById('decayCoeff').textContent = `${analysis.decayCoeff.toFixed(3)} /s`;
                    document.getElementById('halfLife').textContent = `${analysis.halfLife.toFixed(3)} s`;
                    const r2 = Number.isFinite(analysis.rSquared) ? analysis.rSquared : 0;
document.getElementById('rSquared').textContent = r2.toFixed(3);

                    
                    // Ïã†Ìò∏ ÌäπÏÑ±: ÌòÑÏû¨ Î∑∞ Íµ¨Í∞Ñ Í∏∞Ï§ÄÏúºÎ°ú Í≥ÑÏÇ∞
                    this.updateSignalCharacteristics(channelData, sampleRate);
                    
                                      
                    // Ìè¨ÎùΩÏÑ† Ï∞®Ìä∏ Í∑∏Î¶¨Í∏∞
this.drawEnvelopeChart(channelData, analysis.peakIdx, sampleRate);

console.log('Í≤∞Í≥º ÌëúÏãú ÏôÑÎ£å');

} catch (error) {
    console.error('Í≤∞Í≥º ÌëúÏãú Ïò§Î•ò:', error);
}
            }
            
         calculateSignalDuration(channelData, sampleRate) {
    if (!channelData || !sampleRate) return 0;
    
    // dB ÌëúÏãú Î™®ÎìúÏôÄ ÎèôÏùºÌïú Î∞©ÏãùÏúºÎ°ú Í≥ÑÏÇ∞
    const windowSize = Math.max(1, Math.floor(sampleRate * 0.01)); // 10ms ÏúàÎèÑÏö∞
    const dbValues = [];
    
    // 10ms Îã®ÏúÑÎ°ú ÌîºÌÅ¨Í∞í Í≥ÑÏÇ∞ (dB ÌÜ†Í∏ÄÍ≥º ÎèôÏùºÌïú Î°úÏßÅ)
    for (let i = 0; i < channelData.length; i += windowSize) {
        const start = i;
        const end = Math.min(channelData.length, i + windowSize);
        let peak = 0;
        
        for (let j = start; j < end; j++) {
            peak = Math.max(peak, Math.abs(channelData[j]));
        }
        
        const dbfs = 20 * Math.log10(Math.max(peak, 1e-8));
        const dbVal = this.envBaseLevel + (dbfs + 60) * 0.8;
        dbValues.push({
            time: (i + windowSize/2) / sampleRate, // ÏúàÎèÑÏö∞ Ï§ëÏïô ÏãúÍ∞Ñ
            db: dbVal
        });
    }
    
    // ÏûÑÍ≥ÑÍ∞í ÏÑ§Ï†ï: ÌôòÍ≤ΩÍ∏∞Ï§Ä + 15dB (Îçî ÎÜíÍ≤å)
    const threshold = this.envBaseLevel + 15;
    
    // threshold Ïù¥ÏÉÅÏù∏ Ï≤´ ÏßÄÏ†êÍ≥º ÎßàÏßÄÎßâ ÏßÄÏ†ê Ï∞æÍ∏∞
    let startTime = -1;
    let endTime = -1;
    
    for (let i = 0; i < dbValues.length; i++) {
        if (dbValues[i].db >= threshold) {
            if (startTime === -1) {
                startTime = dbValues[i].time;
            }
            endTime = dbValues[i].time;
        }
    }
    
    // ÏãúÏûëÍ≥º ÎÅùÏùÑ Ï∞æÏßÄ Î™ªÌñàÏúºÎ©¥ 0 Î∞òÌôò
    if (startTime === -1 || endTime === -1) return 0;
    
    // ÏßÄÏÜçÏãúÍ∞Ñ Í≥ÑÏÇ∞
    return Math.max(0, endTime - startTime);
}

            updateSignalCharacteristics(channelData, sampleRate) {
                try {
                    if (!channelData || !sampleRate) return;
                    
                    // ÌòÑÏû¨ Î∑∞ Íµ¨Í∞Ñ Í≥ÑÏÇ∞
                    const totalDuration = channelData.length / sampleRate;
                    const viewDuration = totalDuration / this.zoomLevel;
                    const endTime = Math.min(this.scrollOffset + viewDuration, totalDuration);
                    
                    const startSample = Math.floor(this.scrollOffset * sampleRate);
                    const endSample = Math.floor(endTime * sampleRate);
                    const viewData = channelData.slice(startSample, endSample);
                    
                    if (viewData.length === 0) return;
                    
                    // Ï†ÑÏ≤¥ ÌååÏùºÏùò ÏµúÎåÄÍ∞í Í≥ÑÏÇ∞ (Ï§å Î¨¥Í¥Ä)
                    let peak = 0;
                    for (let i = 0; i < channelData.length; i++) {
                        peak = Math.max(peak, Math.abs(channelData[i]));
                    }
                    
                    // dBFS Í≥ÑÏÇ∞
                    const dbfs = 20 * Math.log10(Math.max(peak, 1e-8));
                    
                    // ÌôòÍ≤Ω Í∏∞Ï§Ä dBÎ°ú Î≥ÄÌôò (ÏãúÍ∞ÑÏòÅÏó≠ÌååÌòïÍ≥º ÎèôÏùºÌïú Í≥µÏãù)
                    const dbVal = this.envBaseLevel + (dbfs + 60) * 0.8;
                    
                    // SNR Í≥ÑÏÇ∞ (ÌòÑÏû¨ Î∑∞ Íµ¨Í∞Ñ Í∏∞Ï§Ä)
                    const rms = this.safeRMS(viewData);
                    const snr = 20 * Math.log10(Math.max(peak, 1e-10) / Math.max(rms, 1e-10));
                    
                    // Ïã§Ï†ú Ïã†Ìò∏ ÏßÄÏÜçÏãúÍ∞Ñ Í≥ÑÏÇ∞
                    const signalDuration = this.calculateSignalDuration(channelData, sampleRate);
                    
                    // UI ÏóÖÎç∞Ïù¥Ìä∏
                    document.getElementById('maxAmplitude').textContent = `${dbVal.toFixed(1)} dB`;
                    document.getElementById('duration').textContent = `${signalDuration.toFixed(2)} s`;
                    document.getElementById('snr').textContent = `${snr.toFixed(1)} dB`;
                    
                } catch (error) {
                    console.error('Ïã†Ìò∏ÌäπÏÑ± ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò:', error);
                }
            }
            
            drawScrollableWaveform(channelData, sampleRate) {
                try {
                    console.log('Ïä§ÌÅ¨Î°§ Í∞ÄÎä•Ìïú ÌååÌòï Ï∞®Ìä∏ Í∑∏Î¶¨Í∏∞...');
                    const canvas = document.getElementById('waveformChart');
                    if (!canvas) return;
                    
                    const ctx = canvas.getContext('2d');
                    
                    // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ ÏÑ§Ï†ï
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width || 600;
                    canvas.height = rect.height || 300;
                    
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    // Ï∫îÎ≤ÑÏä§ Ï¥àÍ∏∞Ìôî
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#f8f9fa';
                    ctx.fillRect(0, 0, width, height);
                    
                    // Ï†ÑÏ≤¥ ÏßÄÏÜçÏãúÍ∞ÑÍ≥º Î≥¥Í∏∞ Ï∞Ω Í≥ÑÏÇ∞
                    const totalDuration = channelData.length / sampleRate;
                    const viewDuration = totalDuration / this.zoomLevel;
                    const endTime = Math.min(this.scrollOffset + viewDuration, totalDuration);
                    
                    // ÌëúÏãúÌï† Îç∞Ïù¥ÌÑ∞ Î≤îÏúÑ Í≥ÑÏÇ∞
                    const startSample = Math.floor(this.scrollOffset * sampleRate);
                    const endSample = Math.floor(endTime * sampleRate);
                    const viewData = channelData.slice(startSample, endSample);
                    
                    if (viewData.length === 0) return;
                    
                    // ÏµúÎåÄ ÏßÑÌè≠ Ï∞æÍ∏∞ (Ï†ïÍ∑úÌôîÏö©)
                    let maxAmplitude = 0;
                    for (let i = 0; i < viewData.length; i++) {
                        maxAmplitude = Math.max(maxAmplitude, Math.abs(viewData[i]));
                    }
                    
                   // YÏ∂ï Í≥†Ï†ï Î≤îÏúÑ (-1~+1) ÏÇ¨Ïö©
// amplificationFactor Í≥ÑÏÇ∞ ÏÇ≠Ï†ú
                    
                    // Îç∞Ïù¥ÌÑ∞ Îã§Ïö¥ÏÉòÌîåÎßÅ (ÏÑ±Îä• ÏµúÏ†ÅÌôî)
                    const maxPoints = Math.min(2000, viewData.length);
                    const step = Math.max(1, Math.floor(viewData.length / maxPoints));
                    
                    // ÌååÌòï/ÎòêÎäî dB Ìè¨ÎùΩÏÑ† Í∑∏Î¶¨Í∏∞
                    if (this.dbToggle) {
                        // dB Î™®Îìú: 10ms RMS ‚Üí dBFS(+Ïò§ÌîÑÏÖã)
                        const windowSize = Math.max(1, Math.floor(sampleRate * 0.01));
                        ctx.strokeStyle = '#2d98da';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        let pointsDrawn = 0;
                        for (let i = 0; i < viewData.length; i += step) {
                            const start = Math.max(0, i - Math.floor(windowSize/2));
                            const end = Math.min(viewData.length, start + windowSize);
                            // ÌîºÌÅ¨Í∞í Í∏∞Î∞ò Í≥ÑÏÇ∞ (RMS ÎåÄÏã†)
                            let peak = 0;
                            for (let j = start; j < end; j++) { 
                                const v = Math.abs(viewData[j]); 
                                peak = Math.max(peak, v); 
                            }
                            const dbfs = 20 * Math.log10(Math.max(peak, 1e-8));
                            // dBFSÎ•º Ïã§Ï†ú dBÎ°ú Î≥ÄÌôò: ÌôòÍ≤ΩÍ∏∞Ï§Ä + (dBFS + 60) * 0.8 (Îçî ÎØºÍ∞êÌïòÍ≤å)
                            // dBFS -60dBÎ•º ÌôòÍ≤ΩÍ∏∞Ï§ÄÏúºÎ°ú, dBFS 0dBÎ•º ÌôòÍ≤ΩÍ∏∞Ï§Ä+48dBÎ°ú Îß§Ìïë
                            const dbVal = this.envBaseLevel + (dbfs + 60) * 0.8;
                            // dB Ï∂ï Î≤îÏúÑ: ÌôòÍ≤ΩÍ∏∞Ï§Ä .. ÌôòÍ≤ΩÍ∏∞Ï§Ä+60dB ÌëúÏãú (0dB Ïù¥ÏÉÅÎßå)
                            const dbMin = this.envBaseLevel;
                            const dbMax = this.envBaseLevel + 60;
                            const dbClamped = Math.max(dbMin, Math.min(dbMax, dbVal));
                            const x = (pointsDrawn / maxPoints) * width;
                            const y = height - 30 - ((dbClamped - dbMin) / (dbMax - dbMin)) * (height - 60);
                            if (pointsDrawn === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                            pointsDrawn++;
                            if (pointsDrawn >= maxPoints) break;
                        }
                        ctx.stroke();
                    } else {
                        // ÏõêÎûò ÏÑ†Ìòï ÌååÌòï
                        ctx.strokeStyle = '#667eea';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        let pointsDrawn = 0;
                        for (let i = 0; i < viewData.length; i += step) {
                            const sample = viewData[i] || 0;
                            const clippedSample = Math.max(-1, Math.min(1, sample));
                            const x = (pointsDrawn / maxPoints) * width;
                            const y = height / 2 - (clippedSample * height * 0.4);
                            if (pointsDrawn === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                            pointsDrawn++;
                            if (pointsDrawn >= maxPoints) break;
                        }
                        ctx.stroke();
                    }
                    
                    // Ï§ëÏïôÏÑ†/Í≤©Ïûê: dB Î™®ÎìúÏôÄ ÏÑ†Ìòï Î™®Îìú Î∂ÑÍ∏∞
                    ctx.strokeStyle = '#95a5a6';
                    ctx.lineWidth = 1.5;
                    if (this.dbToggle) {
                        // dB ÎààÍ∏àÏÑ†: ÌôòÍ≤ΩÍ∏∞Ï§Ä Í∏∞Ï§ÄÏúºÎ°ú ÌëúÏãú (0dB Ïù¥ÏÉÅÎßå)
                        const dbMin = this.envBaseLevel;
                        const dbMax = this.envBaseLevel + 60;
                        const dbTicks = [this.envBaseLevel+60, this.envBaseLevel+50, this.envBaseLevel+40, this.envBaseLevel+30, this.envBaseLevel+20, this.envBaseLevel+10, this.envBaseLevel];
                        ctx.setLineDash([3,3]);
                        for (const db of dbTicks) {
                            const y = height - 30 - ((db - dbMin) / (dbMax - dbMin)) * (height - 60);
                            ctx.beginPath();
                            ctx.moveTo(0, y);
                            ctx.lineTo(width, y);
                            ctx.stroke();
                        }
                        ctx.setLineDash([]);
                    } else {
                        // ÏÑ†Ìòï Ï§ëÏïôÏÑ† + Î†àÎ≤®ÏÑ†
                        ctx.beginPath();
                        ctx.moveTo(0, height / 2);
                        ctx.lineTo(width, height / 2);
                        ctx.stroke();
                        ctx.setLineDash([3,3]);
                        const levels = [0.2, 0.4, 0.6, 0.8];
                        for (const level of levels) {
                            ctx.beginPath();
                            ctx.moveTo(0, height / 2 - (height * level * 0.4));
                            ctx.lineTo(width, height / 2 - (height * level * 0.4));
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(0, height / 2 + (height * level * 0.4));
                            ctx.lineTo(width, height / 2 + (height * level * 0.4));
                            ctx.stroke();
                        }
                        ctx.setLineDash([]);
                    }
                    
                 // ÏãúÍ∞ÑÏ∂ï ÎùºÎ≤® (Í≤©ÏûêÏôÄ Ï†ïÌôïÌûà ÏùºÏπò)
ctx.fillStyle = '#2c3e50';
ctx.font = '12px Arial';
ctx.textAlign = 'center';

const labelMargin = 20;

// ÌôîÎ©¥Ïóê ÌëúÏãúÎêòÎäî ÏãúÍ∞Ñ Íµ¨Í∞Ñ
const currentViewDuration = totalDuration / this.zoomLevel;
const startTime = this.scrollOffset;
const viewEndTime = this.scrollOffset + currentViewDuration;  // Ïù¥Î¶Ñ Î≥ÄÍ≤Ω

// Î≥¥Í∏∞ Ï¢ãÏùÄ ÎààÍ∏à Í∞ÑÍ≤© ÏÑ†ÌÉù
const roughStep = currentViewDuration / 8;   // ÎåÄÎûµ 8Ïπ∏ Ï†ïÎèÑ Î≥¥Ïù¥Í≤å
const pow10 = Math.pow(10, Math.floor(Math.log10(roughStep)));
let tickStep = pow10;   // step ‚Üí tickStep ÏúºÎ°ú Î≥ÄÍ≤Ω
if (roughStep / tickStep > 5) tickStep *= 5;
else if (roughStep / tickStep > 2) tickStep *= 2;

// ÏÜåÏàòÏ†ê ÏûêÎ¶øÏàò Í≤∞Ï†ï
const decimals = tickStep < 0.001 ? 6 :
                 tickStep < 0.01  ? 4 :
                 tickStep < 0.1   ? 3 :
                 tickStep < 1     ? 2 :
                 tickStep < 10    ? 1 : 0;

// tickStep Î∞∞ÏàòÎ°ú Ïä§ÎÉÖ
let tick = Math.ceil(startTime / tickStep) * tickStep;
ctx.textAlign = 'center';
ctx.fillStyle = '#2c3e50';
ctx.font = '12px Arial';

// ÎùºÎ≤® Í∑∏Î¶¨Í∏∞
while (tick <= viewEndTime) {
    const x = ((tick - startTime) / currentViewDuration) * width;

 // ÏÑ∏Î°úÏÑ† Ï∂îÍ∞Ä
    ctx.beginPath();
    ctx.moveTo(x, 20);
    ctx.lineTo(x, height - 40);
    ctx.strokeStyle = '#bdc3c7';
    ctx.setLineDash([2, 4]);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillText(`${parseFloat(tick.toFixed(decimals))}s`, x, height - 10);

    tick += tickStep;
}
                    
                    // YÏ∂ï ÎùºÎ≤®
                    ctx.textAlign = 'right';
                    if (this.dbToggle) {
                        const dbMin = this.envBaseLevel;
                        const dbMax = this.envBaseLevel + 60;
                        const dbTicks = [this.envBaseLevel+60, this.envBaseLevel+50, this.envBaseLevel+40, this.envBaseLevel+30, this.envBaseLevel+20, this.envBaseLevel+10, this.envBaseLevel];
                        for (const db of dbTicks) {
                            const y = height - 30 - ((db - dbMin) / (dbMax - dbMin)) * (height - 60);
                            if (y >= 20 && y <= height - 40) ctx.fillText(`${db} dB`, width - 15, y + 4);
                        }
                    } else {
                        ctx.fillText('+1.0', width - 15, 25);
                        ctx.fillText('0.0', width - 15, height / 2 + 5);
                        ctx.fillText('-1.0', width - 15, height - 25);
                    }
                    
                    // ÏÉÅÌÉú Ï†ïÎ≥¥ ÌëúÏãú
                    ctx.textAlign = 'left';
                    ctx.font = '10px Arial';
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillText(`Ï§å: ${this.zoomLevel.toFixed(1)}x`, 10, 20);
                    
                    // Ïä§ÌÅ¨Î°§Î∞î ÌëúÏãú
                    this.drawScrollbar(ctx, width, height, totalDuration, viewDuration);
                    
                    // Ï°∞Ïûë ÏïàÎÇ¥
                    ctx.fillStyle = '#95a5a6';
                    ctx.font = '9px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText('ÎìúÎûòÍ∑∏: Ïä§ÌÅ¨Î°§ | Ìú†: Ï§å | ÎçîÎ∏îÌÅ¥Î¶≠: Î¶¨ÏÖã', width - 10, height - 25);
                    
                    // dB HUD (ÏãúÍ∞ÑÏòÅÏó≠ RMS ‚Üí dBFS ‚Üí Î≥¥Ï†ï Ïò§ÌîÑÏÖã)
                    if (this.dbToggle) {
                        // ÌòÑÏû¨ Î∑∞ Íµ¨Í∞Ñ ÌîºÌÅ¨Í∞í Í≥ÑÏÇ∞ (RMS ÎåÄÏã†)
                        let peak = 0;
                        for (let i=0;i<viewData.length;i++) { 
                            const v = Math.abs(viewData[i]); 
                            peak = Math.max(peak, v); 
                        }
                        // dBFS: full-scale(1.0)Ïóê ÎåÄÌïú dB. Îß§Ïö∞ ÏûëÏùÄ Í∞í Î≥¥Ìò∏
                        const dbfs = 20 * Math.log10(Math.max(peak, 1e-8));
                        const dbEst = this.envBaseLevel + (dbfs + 60) * 0.8;
                        const hud = document.getElementById('dbHud');
                        if (hud) hud.textContent = `Peak ${dbEst.toFixed(1)} dB (ÌôòÍ≤ΩÍ∏∞Ï§Ä)`;
                        // ÌôîÎ©¥ÏóêÎèÑ ÏûëÏùÄ ÌÖçÏä§Ìä∏ ÌëúÏãú
                        ctx.textAlign = 'left';
                        ctx.fillStyle = '#2c3e50';
                        ctx.font = '11px Arial';
                        ctx.fillText(`dB(ÌôòÍ≤ΩÍ∏∞Ï§Ä): ${dbEst.toFixed(1)} dB`, 10, height - 10);
                    } else {
                        const hud = document.getElementById('dbHud');
                        if (hud) hud.textContent = '‚Äî';
                    }

                    // ÏàòÎèô Ïπ¥Ïö¥Ìä∏ ÎßàÏª§ Ïò§Î≤ÑÎ†àÏù¥
                    if (this.manualClicks && this.manualClicks.length > 0) {
                        ctx.save();
                        const totalDuration = channelData.length / sampleRate;
                        const viewDurationNow = totalDuration / this.zoomLevel;
                        const startSample = Math.floor(this.scrollOffset * sampleRate);
                        const endSample = Math.floor((this.scrollOffset + viewDurationNow) * sampleRate);

                        ctx.strokeStyle = '#e67e22';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([4, 3]);
                        for (const idx of this.manualClicks) {
                            if (idx < startSample || idx > endSample) continue;
                            const t = (idx / sampleRate - this.scrollOffset) / viewDurationNow;
                            const x = t * width;
                            ctx.beginPath();
                            ctx.moveTo(x, 20);
                            ctx.lineTo(x, height - 40);
                            ctx.stroke();
                        }
                        ctx.setLineDash([]);

                        // Ï£ºÌååÏàò ÌÖçÏä§Ìä∏(ÏÉÅÎã® Ï¢åÏ∏°)
                        if (this.manualClicks.length >= 2) {
                            const first = this.manualClicks[0];
                            const last = this.manualClicks[this.manualClicks.length - 1];
                            const dt = Math.max(0, (last - first) / sampleRate);
                            const cycles = Math.max(0, this.manualClicks.length - 1);
                            const f = dt > 0 && cycles > 0 ? cycles / dt : 0;
                            ctx.fillStyle = '#e67e22';
                            ctx.font = '12px Arial';
                            ctx.textAlign = 'left';
                            ctx.fillText(`ÏàòÎèô f‚âà${f.toFixed(1)}Hz (N=${cycles}, Œît=${dt.toFixed(3)}s)`, 10, 36);
                        }

                        ctx.restore();
                    }

                    // ÎìúÎûòÍ∑∏ ÏÑ†ÌÉù Ïò§Î≤ÑÎ†àÏù¥ Î∞è ÏûêÎèô Ï£ºÌååÏàò Í≤∞Í≥º
                    if (this.manualMode) {
                        ctx.save();
                        if (this.manualSelStartX != null && this.manualSelEndX != null) {
                            const sx = Math.min(this.manualSelStartX, this.manualSelEndX);
                            const ex = Math.max(this.manualSelStartX, this.manualSelEndX);
                            ctx.fillStyle = 'rgba(102, 126, 234, 0.15)';
                            ctx.fillRect(sx, 20, Math.max(0, ex - sx), height - 60);
                            ctx.strokeStyle = '#667eea';
                            ctx.setLineDash([5,3]);
                            ctx.beginPath();
                            ctx.moveTo(sx, 20);
                            ctx.lineTo(sx, height - 40);
                            ctx.moveTo(ex, 20);
                            ctx.lineTo(ex, height - 40);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                        if (this.manualAutoResult && Number.isFinite(this.manualAutoResult.f)) {
                            ctx.fillStyle = '#667eea';
                            ctx.font = '12px Arial';
                            ctx.textAlign = 'left';
                            ctx.fillText(`Íµ¨Í∞Ñ ÏûêÎèô f‚âà${this.manualAutoResult.f.toFixed(1)}Hz`, 10, 50);
                            // ÍµêÏ∞®ÏÑ† ÌëúÏãú
                            const totalDurationNow = channelData.length / sampleRate;
                            const viewDurationNow2 = totalDurationNow / this.zoomLevel;
                            ctx.strokeStyle = 'rgba(46, 134, 222, 0.9)';
                            ctx.lineWidth = 1;
                            ctx.setLineDash([2,2]);
                            for (const idx of (this.manualAutoResult.crossings || [])) {
                                if (idx < Math.floor(this.scrollOffset * sampleRate) || idx > Math.floor((this.scrollOffset + viewDurationNow2) * sampleRate)) continue;
                                const t = (idx / sampleRate - this.scrollOffset) / viewDurationNow2;
                                const x = t * width;
                                ctx.beginPath();
                                ctx.moveTo(x, 20);
                                ctx.lineTo(x, height - 40);
                                ctx.stroke();
                            }
                            ctx.setLineDash([]);
                        }
                        ctx.restore();
                    }

                    // Ïã†Ìò∏ÌäπÏÑ± Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ (ÌòÑÏû¨ Î∑∞ Íµ¨Í∞Ñ Í∏∞Ï§Ä)
                    this.updateSignalCharacteristics(channelData, sampleRate);
                    
                    console.log('Ïä§ÌÅ¨Î°§ Í∞ÄÎä•Ìïú ÌååÌòï Ï∞®Ìä∏ ÏôÑÎ£å');
                    
                } catch (error) {
                    console.error('Ïä§ÌÅ¨Î°§ ÌååÌòï Ï∞®Ìä∏ Ïò§Î•ò:', error);
                }
            }
            
            drawScrollbar(ctx, width, height, totalDuration, viewDuration) {
                // Ïä§ÌÅ¨Î°§Î∞î Î∞∞Í≤Ω
                const scrollbarHeight = 8;
                const scrollbarY = height - 40;
                
                ctx.fillStyle = '#ecf0f1';
                ctx.fillRect(0, scrollbarY, width, scrollbarHeight);
                
                // Ïä§ÌÅ¨Î°§Î∞î Ìï∏Îì§
                const handleWidth = (viewDuration / totalDuration) * width;
                const handleX = (this.scrollOffset / totalDuration) * width;
                
                ctx.fillStyle = '#3498db';
                ctx.fillRect(handleX, scrollbarY, handleWidth, scrollbarHeight);
                
                // Ïä§ÌÅ¨Î°§Î∞î ÌÖåÎëêÎ¶¨
                ctx.strokeStyle = '#bdc3c7';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, scrollbarY, width, scrollbarHeight);
            }
            
            drawRealSpectrum(spectrum, freqBins, sampleRate) {
                try {
                    console.log('Ïã§Ï†ú FFT Ïä§ÌéôÌä∏Îüº Ï∞®Ìä∏ Í∑∏Î¶¨Í∏∞...');
                    const canvas = document.getElementById('spectrumChart');
                    if (!canvas) return;
                    
                    const ctx = canvas.getContext('2d');
                    
                    // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ ÏÑ§Ï†ï
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width || 600;
                    canvas.height = rect.height || 300;
                    
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    // Ï∫îÎ≤ÑÏä§ Ï¥àÍ∏∞Ìôî
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#f8f9fa';
                    ctx.fillRect(0, 0, width, height);
                    
                    if (spectrum.length === 0) return;
                    
                    // ÌëúÏãúÌï† Ï£ºÌååÏàò Î≤îÏúÑ (0 ~ 5000Hz)
                    const maxFreq = Math.min(5000, sampleRate / 2);
                    const displaySpectrum = [];
                    const displayFreqs = [];
                    
                    // Ï£ºÌååÏàò ÎπàÏù¥ ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Í≥ÑÏÇ∞
                    if (freqBins.length > 0) {
                        for (let i = 0; i < spectrum.length && i < freqBins.length; i++) {
                            if (freqBins[i] <= maxFreq) {
                                displaySpectrum.push(spectrum[i]);
                                displayFreqs.push(freqBins[i]);
                            }
                        }
                    } else {
                        // Ìè¥Î∞±: Ï£ºÌååÏàò Îπà Í≥ÑÏÇ∞
                        for (let i = 0; i < spectrum.length; i++) {
                            const freq = (i / spectrum.length) * (sampleRate / 2);
                            if (freq <= maxFreq) {
                                displaySpectrum.push(spectrum[i]);
                                displayFreqs.push(freq);
                            }
                        }
                    }
                    
                    console.log('Ïä§ÌéôÌä∏Îüº ÌëúÏãú Ï†ïÎ≥¥:', {
                        originalLength: spectrum.length,
                        displayLength: displaySpectrum.length,
                        maxFreq: maxFreq,
                        freqRange: displayFreqs.length > 0 ? 
                            `${displayFreqs[0].toFixed(1)} - ${displayFreqs[displayFreqs.length-1].toFixed(1)} Hz` : 'N/A'
                    });
                    
                    if (displaySpectrum.length === 0) return;
                    
                    // Î°úÍ∑∏ Ïä§ÏºÄÏùº Ï£ºÌååÏàòÏ∂ï ÏÑ§Ï†ï
                    const useLogScale = true;
                    const minFreq = Math.max(20, displayFreqs[0] || 20); // ÏµúÏÜå 20Hz
                    
                    // ÎßâÎåÄ Í∑∏ÎûòÌîÑÎ°ú Í∑∏Î¶¨Í∏∞
                    const barWidth = width / displaySpectrum.length;
                    
                   for (let i = 0; i < displaySpectrum.length; i++) {
    const magnitude = displaySpectrum[i];
    const magnitudeDB = 20 * Math.log10(Math.max(magnitude, 1e-6)); // dB Î≥ÄÌôò
    const normalizedDB = Math.max(0, (magnitudeDB + 60) / 60); // -60dB ~ 0dBÎ•º 0~1Î°ú Ï†ïÍ∑úÌôî
    const freq = displayFreqs[i];
                        
                        let x;
                        if (useLogScale && freq > 0) {
                            // Î°úÍ∑∏ Ïä§ÏºÄÏùº
                            const logMin = Math.log10(minFreq);
                            const logMax = Math.log10(maxFreq);
                            const logFreq = Math.log10(Math.max(freq, minFreq));
                            x = ((logFreq - logMin) / (logMax - logMin)) * width;
                        } else {
                            // ÏÑ†Ìòï Ïä§ÏºÄÏùº
                            x = (freq / maxFreq) * width;
                        }
                        
                       const barHeight = normalizedDB * (height - 60); // dB Í∏∞Ï§Ä ÎÜíÏù¥
                        const y = height - barHeight - 30;
                        
                        // Ï£ºÌååÏàòÏóê Îî∞Î•∏ ÏÉâÏÉÅ (ÌååÎûÄÏÉâ -> Îπ®Í∞ÑÏÉâ)
                        const hue = 240 - (freq / maxFreq) * 180; // 240(ÌååÎûÄÏÉâ) -> 60(ÎÖ∏ÎûÄÏÉâ) -> 0(Îπ®Í∞ÑÏÉâ)
                        const saturation = 70;
                        const lightness = 50;
                        const alpha = 0.7 + normalizedDB * 0.3; // dB Í∏∞Ï§Ä Ìà¨Î™ÖÎèÑ
                        
                        ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                        
                        // ÎßâÎåÄ ÎÑàÎπÑ Í≥ÑÏÇ∞ (Î°úÍ∑∏ Ïä§ÏºÄÏùº Í≥†Î†§)
                        let nextX = width;
                        if (i < displaySpectrum.length - 1) {
                            const nextFreq = displayFreqs[i + 1];
                            if (useLogScale && nextFreq > 0) {
                                const logMin = Math.log10(minFreq);
                                const logMax = Math.log10(maxFreq);
                                const logNextFreq = Math.log10(Math.max(nextFreq, minFreq));
                                nextX = ((logNextFreq - logMin) / (logMax - logMin)) * width;
                            } else {
                                nextX = (nextFreq / maxFreq) * width;
                            }
                        }
                        
                        const actualBarWidth = Math.max(1, nextX - x);
                        ctx.fillRect(x, y, actualBarWidth, barHeight);
                    }
                    
                    // Ï£ºÌååÏàò Ï∂ï ÎùºÎ≤® (Î°úÍ∑∏ Ïä§ÏºÄÏùº)
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'center';
                    
                    const freqLabels = useLogScale ? 
                        [20, 50, 100, 200, 500, 1000, 2000, 5000] :
                        [0, maxFreq/4, maxFreq/2, 3*maxFreq/4, maxFreq];
                    
                    for (const freq of freqLabels) {
                        if (freq <= maxFreq && freq >= minFreq) {
                            let x;
                            if (useLogScale) {
                                const logMin = Math.log10(minFreq);
                                const logMax = Math.log10(maxFreq);
                                const logFreq = Math.log10(freq);
                                x = ((logFreq - logMin) / (logMax - logMin)) * width;
                            } else {
                                x = (freq / maxFreq) * width;
                            }
                            
                            let label;
                            if (freq >= 1000) {
                                label = `${(freq/1000).toFixed(freq % 1000 === 0 ? 0 : 1)}k`;
                            } else {
                                label = `${freq}`;
                            }
                            
                            ctx.fillText(label, x, height - 5);
                            
                            // Í≤©ÏûêÏÑ†
                            ctx.strokeStyle = '#e0e0e0';
                            ctx.lineWidth = 1;
                            ctx.setLineDash([2, 2]);
                            ctx.beginPath();
                            ctx.moveTo(x, height - 30);
                            ctx.lineTo(x, 30);
                            ctx.stroke();
                            ctx.setLineDash([]);

                        }
                    }
                    
                   // dB Ï∂ï ÎùºÎ≤® (Îçî Ï†ïÎ∞ÄÌïòÍ≤å)
ctx.textAlign = 'right';
const dbLevels = [0, -10, -20, -30, -40, -50, -60];
for (const db of dbLevels) {
    const y = 30 + ((0 - db) / 60) * (height - 60);
    if (y >= 30 && y <= height - 30) {
        ctx.fillText(`${db}dB`, width - 5, y + 4);
        
        // Í≤©ÏûêÏÑ† Ï∂îÍ∞Ä
        if (db !== 0) {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            ctx.setLineDash([1, 2]);
            ctx.beginPath();
            ctx.moveTo(20, y);
            ctx.lineTo(width - 40, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
}
                    
                    // Ï†úÎ™©Í≥º Ï†ïÎ≥¥
                    ctx.textAlign = 'left';
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#2c3e50';
                    ctx.fillText('Ï£ºÌååÏàò Ïä§ÌéôÌä∏Îüº (Ïã§Ï†ú FFT)', 10, 20);
                    
                    ctx.font = '10px Arial';
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillText(`FFT ÌÅ¨Í∏∞: ${spectrum.length * 2} | ${useLogScale ? 'Î°úÍ∑∏' : 'ÏÑ†Ìòï'} Ïä§ÏºÄÏùº`, 10, height - 10);
                    
                    // Ï£ºÏöî ÌîºÌÅ¨ ÌëúÏãú
                    this.markSpectralPeaks(ctx, displaySpectrum, displayFreqs, width, height, useLogScale, minFreq, maxFreq);
                    
                    console.log('Ïã§Ï†ú FFT Ïä§ÌéôÌä∏Îüº Ï∞®Ìä∏ ÏôÑÎ£å');
                    
                } catch (error) {
                    console.error('Ïã§Ï†ú Ïä§ÌéôÌä∏Îüº Ï∞®Ìä∏ Ïò§Î•ò:', error);
                }
            }
            
            markSpectralPeaks(ctx, spectrum, freqs, width, height, useLogScale, minFreq, maxFreq) {
                try {
                    // ÌîºÌÅ¨ Ï∞æÍ∏∞ (ÏûÑÍ≥ÑÍ∞í Ïù¥ÏÉÅ)
                    const threshold = Math.max(...spectrum) * 0.3; // 30% ÏûÑÍ≥ÑÍ∞í
                    const peaks = [];
                    
                    for (let i = 1; i < spectrum.length - 1; i++) {
                        if (spectrum[i] > threshold && 
                            spectrum[i] > spectrum[i-1] && 
                            spectrum[i] > spectrum[i+1]) {
                            peaks.push({ freq: freqs[i], magnitude: spectrum[i], index: i });
                        }
                    }
                    
                    // ÏÉÅÏúÑ 3Í∞ú ÌîºÌÅ¨Îßå ÌëúÏãú
                    peaks.sort((a, b) => b.magnitude - a.magnitude);
                    const topPeaks = peaks.slice(0, 3);
                    
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '9px Arial';
                    ctx.textAlign = 'center';
                    
                    for (const peak of topPeaks) {
                        let x;
                        if (useLogScale && peak.freq > 0) {
                            const logMin = Math.log10(minFreq);
                            const logMax = Math.log10(maxFreq);
                            const logFreq = Math.log10(Math.max(peak.freq, minFreq));
                            x = ((logFreq - logMin) / (logMax - logMin)) * width;
                        } else {
                            x = (peak.freq / maxFreq) * width;
                        }
                        
                        const y = height - peak.magnitude * (height - 60) - 30;
                        
                        // ÌîºÌÅ¨ ÎßàÏª§
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Ï£ºÌååÏàò ÎùºÎ≤®
                        const freqLabel = peak.freq >= 1000 ? 
                            `${(peak.freq/1000).toFixed(1)}kHz` : 
                            `${Math.round(peak.freq)}Hz`;
                        
                        ctx.fillText(freqLabel, x, y - 8);
                    }
                    
                } catch (error) {
                    console.error('ÌîºÌÅ¨ ÌëúÏãú Ïò§Î•ò:', error);
                }
            }
            
            // Ïã§ÏãúÍ∞Ñ ÎÖπÏùå Í∏∞Îä• (ÏõêÎ≥∏ Í∑∏ÎåÄÎ°ú Î≥µÏõê)
          async startRealTimeRecording() {
    // Ï§ëÎ≥µ Ïã§Ìñâ Î∞©ÏßÄ
    if (this.isCountingDown || this.isRecording) return;
    
    // Ï¶âÏãú ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÏöîÏ≤≠
    this.updateStatus('ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏùÑ ÏöîÏ≤≠ÌïòÍ≥† ÏûàÏäµÎãàÎã§...', 'analyzing');
    
    try {
        // ÎßàÏù¥ÌÅ¨ Í∂åÌïúÎ∂ÄÌÑ∞ Î®ºÏ†Ä ÌôïÏù∏
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî ÎßàÏù¥ÌÅ¨ Ï†ëÍ∑ºÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
        }
        
        const constraints = {
            audio: {
                sampleRate: 44100,
                channelCount: 1,
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: false
            }
        };
        
       // ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÌÖåÏä§Ìä∏ Î∞è Ïä§Ìä∏Î¶º Ï§ÄÎπÑ
const testStream = await navigator.mediaDevices.getUserMedia(constraints);
this.preparedStream = testStream; // Ïä§Ìä∏Î¶ºÏùÑ Ï†ÄÏû•Ìï¥ÏÑú Ïû¨ÏÇ¨Ïö©
        
        this.updateStatus('ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏù¥ ÏäπÏù∏ÎêòÏóàÏäµÎãàÎã§! 10Ï¥à ÌõÑ ÎÖπÏùåÏùÑ ÏãúÏûëÌï©ÎãàÎã§.', 'analyzing');
        
        // Í∂åÌïú ÏäπÏù∏ ÌõÑ Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÏãúÏûë
        this.isCountingDown = true;
        let countdown = 10;
        const recordBtn = document.getElementById('recordBtn');
        
        this.countdownInterval = setInterval(() => {
            recordBtn.textContent = `üî¥ ${countdown}Ï¥à ÌõÑ ÏãúÏûë`;
            this.updateStatus(`${countdown}Ï¥à ÌõÑ ÎÖπÏùåÏùÑ ÏãúÏûëÌï©ÎãàÎã§.`, 'analyzing');
            countdown--;
            
            if (countdown < 0) {
                clearInterval(this.countdownInterval);
                this.countdownInterval = null;
                this.isCountingDown = false;
                this.startActualRecording();
            }
        }, 1000);
        
    } catch (error) {
        console.error('ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÏöîÏ≤≠ Ïã§Ìå®:', error);
        
        let errorMessage = 'ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÏöîÏ≤≠Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. ';
        if (error.name === 'NotAllowedError') {
            errorMessage = 'ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§. Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ïÏóêÏÑú ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏùÑ ÌóàÏö©Ìï¥Ï£ºÏÑ∏Ïöî.';
        } else if (error.name === 'NotFoundError') {
            errorMessage = 'ÎßàÏù¥ÌÅ¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Í∏∞Í∏∞Ïóê ÎßàÏù¥ÌÅ¨Í∞Ä Ïó∞Í≤∞ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.';
        } else if (error.name === 'NotSupportedError') {
            errorMessage = 'Ïù¥ Î∏åÎùºÏö∞Ï†ÄÏóêÏÑúÎäî ÎÖπÏùåÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§. Chrome Î∏åÎùºÏö∞Ï†ÄÎ•º ÏÇ¨Ïö©Ìï¥Î≥¥ÏÑ∏Ïöî.';
        } else {
            errorMessage += error.message;
        }
        
        this.updateStatus(errorMessage, 'error');
    }
}

async playBeepSound() {
    try {
        // Ïù¥ÎØ∏ ÏÉùÏÑ±Îêú AudioContext ÏÇ¨Ïö©
        const audioContext = this.audioContext;
        
        // ÎπÑÌîÑÏùå ÏÉùÏÑ± (800Hz, 0.2Ï¥à)
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // Ï£ºÌååÏàòÏôÄ Î≥ºÎ•® ÏÑ§Ï†ï
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // 800Hz
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); // Î≥ºÎ•® 30%
        
        // ÌéòÏù¥Îìú ÏïÑÏõÉ Ìö®Í≥º
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
        
        // ÎπÑÌîÑÏùå Ïû¨ÏÉù
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.2);
        
        // ÎπÑÌîÑÏùåÏù¥ ÎÅùÎÇ† ÎïåÍπåÏßÄ ÎåÄÍ∏∞
        await new Promise(resolve => setTimeout(resolve, 250));
        
    } catch (error) {
        console.log('ÎπÑÌîÑÏùå Ïû¨ÏÉù Ïã§Ìå®:', error);
        // ÏóêÎü¨Í∞Ä ÎÇòÎèÑ ÎÖπÏùåÏùÄ Í≥ÑÏÜç ÏßÑÌñâ
    }
}

async startActualRecording() {
     try {
      
                            
                    // Í∞§Îü≠Ïãú ÏµúÏ†ÅÌôî: AudioContext Î®ºÏ†Ä ÏÉùÏÑ± Î∞è ÌôúÏÑ±Ìôî
                    console.log('AudioContext ÏÉùÏÑ± Î∞è ÌôúÏÑ±Ìôî...');
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                        console.log('AudioContext ÌôúÏÑ±Ìôî ÏôÑÎ£å:', this.audioContext.state);
                    }
                    
                    // Í∞§Îü≠Ïãú(Android Chrome) ÏµúÏ†ÅÌôî Ïò§ÎîîÏò§ ÏÑ§Ï†ï
                    const constraints = {
                        audio: {
                            sampleRate: 44100,
                            channelCount: 1,
                            echoCancellation: true,     // Í∞§Îü≠ÏãúÏóêÏÑú Ï§ëÏöî
                            noiseSuppression: true,     // Í∞§Îü≠ÏãúÏóêÏÑú Ï§ëÏöî
                            autoGainControl: false
                        }
                    };
                    
                   console.log('Ï†ÄÏû•Îêú ÎßàÏù¥ÌÅ¨ Ïä§Ìä∏Î¶º ÏÇ¨Ïö©...');
const stream = this.preparedStream; // Ïù¥ÎØ∏ Ï§ÄÎπÑÎêú Ïä§Ìä∏Î¶º ÏÇ¨Ïö©
console.log('ÎßàÏù¥ÌÅ¨ Ïä§Ìä∏Î¶º ÏÇ¨Ïö© Ï§ÄÎπÑ ÏôÑÎ£å');
                    
                    // Í∞§Îü≠ÏãúÏö© MIME ÌÉÄÏûÖ Ï≤¥ÌÅ¨ (Ïö∞ÏÑ†ÏàúÏúÑ: webm > mp4 > wav)
                    let options = {};
                    let mimeType = 'audio/webm;codecs=opus';  // Í∞§Îü≠Ïãú ÏÑ†Ìò∏ Ìè¨Îß∑
                    
                    if (MediaRecorder.isTypeSupported(mimeType)) {
                        options.mimeType = mimeType;
                        console.log('MIME ÌÉÄÏûÖ ÏÑ§Ï†ï: audio/webm;codecs=opus');
                    } else if (MediaRecorder.isTypeSupported('audio/webm')) {
                        options.mimeType = 'audio/webm';
                        console.log('MIME ÌÉÄÏûÖ ÏÑ§Ï†ï: audio/webm');
                    } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                        options.mimeType = 'audio/mp4';
                        console.log('MIME ÌÉÄÏûÖ ÏÑ§Ï†ï: audio/mp4');
                    } else if (MediaRecorder.isTypeSupported('audio/wav')) {
                        options.mimeType = 'audio/wav';
                        console.log('MIME ÌÉÄÏûÖ ÏÑ§Ï†ï: audio/wav');
                    } else {
                        console.log('Í∏∞Î≥∏ MIME ÌÉÄÏûÖ ÏÇ¨Ïö©');
                    }
                    
                    console.log('MediaRecorder ÏÑ§Ï†ï:', options);
                    
                    this.mediaRecorder = new MediaRecorder(stream, options);
                    this.recordedChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        console.log('Îç∞Ïù¥ÌÑ∞ ÏàòÏã†:', event.data.size, 'bytes');
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = async () => {
                        console.log('ÎÖπÏùå Ï§ëÏßÄ, Ï¥ù Ï≤≠ÌÅ¨:', this.recordedChunks.length);
                        const finalMimeType = this.mediaRecorder.mimeType || options.mimeType || 'audio/wav';
                        const audioBlob = new Blob(this.recordedChunks, { type: finalMimeType });
                        console.log('ÏÉùÏÑ±Îêú Blob:', audioBlob.size, 'bytes, type:', audioBlob.type);
                        await this.processRecordedAudio(audioBlob);
                    };
                    
                    this.mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder Ïò§Î•ò:', event.error);
                        this.updateStatus(`ÎÖπÏùå Ï§ë Ïò§Î•ò: ${event.error.message}`, 'error');
                    };
                    
                    this.currentStream = stream;
                    this.isRecording = true;
                    
// ÎÖπÏùå ÏãúÏûë ÏßÅÏ†ÑÏóê ÎπÑÌîÑÏùå Ïû¨ÏÉù
await this.playBeepSound();

                    // Í∞§Îü≠Ïãú ÏµúÏ†ÅÌôî: Îçî Í∏¥ Í∞ÑÍ≤©ÏúºÎ°ú Îç∞Ïù¥ÌÑ∞ ÏàòÏßë (ÏïàÏ†ïÏÑ± Ìñ•ÏÉÅ)
                    this.mediaRecorder.start(2000); // 1Ï¥à ‚Üí 2Ï¥àÎ°ú Ï¶ùÍ∞Ä
                    console.log('ÎÖπÏùå ÏãúÏûë (2Ï¥à Í∞ÑÍ≤©)');
                    
                    const recordBtn = document.getElementById('recordBtn');
                    recordBtn.textContent = 'üî¥ ÎÖπÏùå Ï§ë...';
                    recordBtn.classList.add('recording');
                    
                    this.updateStatus('Ïã§ÏãúÍ∞Ñ ÎÖπÏùå Ï§ëÏûÖÎãàÎã§. Ïû¨ÏßàÏùÑ ÌÉÄÍ≤©ÌïòÍ≥† ÏµúÏÜå 3Ï¥à Ïù¥ÏÉÅ ÎÖπÏùåÌï¥Ï£ºÏÑ∏Ïöî.', 'analyzing');
                    
                    // ÏûêÎèô Ï§ëÏßÄ ÌÉÄÏù¥Î®∏ (10Ï¥à ÌõÑ)
                    this.autoStopTimer = setTimeout(() => {
                        if (this.isRecording) {
                            console.log('ÏûêÎèô Ï§ëÏßÄ (10Ï¥à Í≤ΩÍ≥º)');
                            this.stopRealTimeRecording();
                        }
                    }, 10000);
                    
                } catch (error) {
                    console.error('Ïã§ÏãúÍ∞Ñ ÎÖπÏùå Ïò§Î•ò:', error);
                    
                    // Í∞§Îü≠ÏãúÏö© ÏÉÅÏÑ∏ ÏóêÎü¨ Î©îÏãúÏßÄ
                    let errorMessage = 'Ïã§ÏãúÍ∞Ñ ÎÖπÏùåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. ';
                    if (error.name === 'NotAllowedError') {
                        errorMessage = 'ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§. Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ïÏóêÏÑú ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏùÑ ÌóàÏö©Ìï¥Ï£ºÏÑ∏Ïöî.';
                    } else if (error.name === 'NotFoundError') {
                        errorMessage = 'ÎßàÏù¥ÌÅ¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Í∏∞Í∏∞Ïóê ÎßàÏù¥ÌÅ¨Í∞Ä Ïó∞Í≤∞ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.';
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage = 'Ïù¥ Î∏åÎùºÏö∞Ï†ÄÏóêÏÑúÎäî ÎÖπÏùåÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§. Chrome Î∏åÎùºÏö∞Ï†ÄÎ•º ÏÇ¨Ïö©Ìï¥Î≥¥ÏÑ∏Ïöî.';
                    } else {
                        errorMessage += error.message;
                    }
                    
                    this.updateStatus(errorMessage, 'error');
                }
            }
            
            stopRealTimeRecording() {
// Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ Ï§ëÏù¥Î©¥ Ï∑®ÏÜå
if (this.isCountingDown) {
    clearInterval(this.countdownInterval);
    this.countdownInterval = null;
    this.isCountingDown = false;
    const recordBtn = document.getElementById('recordBtn');
    recordBtn.textContent = 'üé§ Ïã§ÏãúÍ∞Ñ ÎÖπÏùå';
    this.updateStatus('Ïπ¥Ïö¥Ìä∏Îã§Ïö¥Ïù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.', 'ready');
    return;
}

                if (this.isRecording && this.mediaRecorder) {
                    console.log('ÎÖπÏùå Ï§ëÏßÄ ÏöîÏ≤≠');
                    
                    // ÏûêÎèô Ï§ëÏßÄ ÌÉÄÏù¥Î®∏ Ìï¥Ï†ú
                    if (this.autoStopTimer) {
                        clearTimeout(this.autoStopTimer);
                        this.autoStopTimer = null;
                    }
                    
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    
                    if (this.currentStream) {
                        this.currentStream.getTracks().forEach(track => {
                            track.stop();
                            console.log('Ìä∏Îûô Ï§ëÏßÄ:', track.kind);
                        });
                        this.currentStream = null;
                    }
                    
                    if (this.audioContext && this.audioContext.state !== 'closed') {
                        this.audioContext.close();
                        this.audioContext = null;
                    }
                    
                    const recordBtn = document.getElementById('recordBtn');
                    recordBtn.textContent = 'üé§ Ïã§ÏãúÍ∞Ñ ÎÖπÏùå';
                    recordBtn.classList.remove('recording');
                    
                    this.updateStatus('ÎÖπÏùåÏùÑ Ï§ëÏßÄÌïòÍ≥† Î∂ÑÏÑùÏùÑ ÏãúÏûëÌï©ÎãàÎã§...', 'analyzing');
                    console.log('ÎÖπÏùå Ï§ëÏßÄ ÏôÑÎ£å');
                }
            }
            
            async processRecordedAudio(audioBlob) {
                try {
                    console.log('ÎÖπÏùåÎêú Blob Ï†ïÎ≥¥:', {
                        size: audioBlob.size,
                        type: audioBlob.type
                    });
                    
                    // 1Îã®Í≥Ñ: Blob ÌÅ¨Í∏∞ ÌôïÏù∏
                    if (audioBlob.size < 1000) {
                        throw new Error('ÎÖπÏùå Îç∞Ïù¥ÌÑ∞Í∞Ä ÎÑàÎ¨¥ ÏûëÏäµÎãàÎã§. Îçî Ïò§Îûò ÎÖπÏùåÌï¥Ï£ºÏÑ∏Ïöî.');
                    }
                    
                    // 2Îã®Í≥Ñ: ArrayBuffer Î≥ÄÌôò
                    console.log('ArrayBuffer Î≥ÄÌôò Ï§ë...');
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    console.log('ArrayBuffer ÌÅ¨Í∏∞:', arrayBuffer.byteLength);
                    
                    // 3Îã®Í≥Ñ: Ïò§ÎîîÏò§ Ïª®ÌÖçÏä§Ìä∏ ÏÉùÏÑ±
                    console.log('AudioContext ÏÉùÏÑ± Ï§ë...');
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // 4Îã®Í≥Ñ: Ïò§ÎîîÏò§ ÎîîÏΩîÎî© (Îçî ÏïàÏ†ÑÌïú Î∞©Î≤ï)
                    console.log('Ïò§ÎîîÏò§ ÎîîÏΩîÎî© Ï§ë...');
                    let audioBuffer;
                    
                    try {
                        audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        console.log('ÎîîÏΩîÎî© ÏÑ±Í≥µ:', {
                            duration: audioBuffer.duration,
                            sampleRate: audioBuffer.sampleRate,
                            channels: audioBuffer.numberOfChannels
                        });
                    } catch (decodeError) {
                        console.error('ÎîîÏΩîÎî© Ïò§Î•ò:', decodeError);
                        
                        // Ìè¥Î∞±: WAV ÌòïÏãùÏúºÎ°ú Ïû¨ÏãúÎèÑ
                        console.log('WAV ÌòïÏãùÏúºÎ°ú Ïû¨ÏãúÎèÑ...');
                        const wavBlob = await this.convertToWav(audioBlob);
                        const wavArrayBuffer = await wavBlob.arrayBuffer();
                        audioBuffer = await audioContext.decodeAudioData(wavArrayBuffer);
                    }
                    
                    // 5Îã®Í≥Ñ: Ïò§ÎîîÏò§ Î≤ÑÌçº Ïú†Ìö®ÏÑ± ÌôïÏù∏
                    if (!audioBuffer || audioBuffer.duration < 0.1) {
                        throw new Error('Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ïò§ÎîîÏò§ Îç∞Ïù¥ÌÑ∞ÏûÖÎãàÎã§.');
                    }
                    
                    // 6Îã®Í≥Ñ: Î∂ÑÏÑù Ïã§Ìñâ
                    console.log('Î∂ÑÏÑù ÏãúÏûë...');
                    await this.analyzeAudioBuffer(audioBuffer);
                    
                } catch (error) {
                    console.error('ÎÖπÏùå Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ïò§Î•ò:', error);
                    
                    let errorMessage = 'ÎÖπÏùå Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ';
                    
                    if (error.message.includes('ÎÑàÎ¨¥ ÏûëÏäµÎãàÎã§')) {
                        errorMessage = 'ÎÖπÏùå ÏãúÍ∞ÑÏù¥ ÎÑàÎ¨¥ ÏßßÏäµÎãàÎã§. 3Ï¥à Ïù¥ÏÉÅ ÎÖπÏùåÌï¥Ï£ºÏÑ∏Ïöî.';
                    } else if (error.message.includes('ÎîîÏΩîÎî©')) {
                        errorMessage = 'Ïò§ÎîîÏò§ ÌòïÏãùÏùÑ Ïù∏ÏãùÌï† Ïàò ÏóÜÏäµÎãàÎã§. Îã§Î•∏ Î∏åÎùºÏö∞Ï†ÄÎ•º ÏãúÎèÑÌï¥Î≥¥ÏÑ∏Ïöî.';
                    } else if (error.message.includes('Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ')) {
                        errorMessage = 'ÎÖπÏùåÎêú Ïò§ÎîîÏò§Í∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§. Îã§Ïãú ÎÖπÏùåÌï¥Ï£ºÏÑ∏Ïöî.';
                    } else {
                        errorMessage += error.message;
                    }
                    
                    this.updateStatus(errorMessage, 'error');
                    
                    // ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥ ÌëúÏãú
                    this.showDebugInfo(error, audioBlob);
                }
            }
            
            async convertToWav(audioBlob) {
                // Í∞ÑÎã®Ìïú WAV Î≥ÄÌôò (Ïã§Ï†úÎ°úÎäî Îçî Ï†ïÍµêÌïú Î≥ÄÌôò ÌïÑÏöî)
                return audioBlob; // ÏûÑÏãú Íµ¨ÌòÑ
            }
            
            showDebugInfo(error, audioBlob) {
                const debugInfo = `
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 10px; padding: 15px; margin: 15px 0; font-size: 0.9em;">
                        <h4 style="color: #856404; margin-bottom: 10px;">üîß ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥</h4>
                        <p><strong>Ïò§Î•ò:</strong> ${error.message}</p>
                        <p><strong>Blob ÌÅ¨Í∏∞:</strong> ${audioBlob.size} bytes</p>
                        <p><strong>Blob ÌÉÄÏûÖ:</strong> ${audioBlob.type}</p>
                        <p><strong>Î∏åÎùºÏö∞Ï†Ä:</strong> ${navigator.userAgent}</p>
                        <p style="margin-top: 10px; color: #856404;">
                            <strong>Ìï¥Í≤∞ Î∞©Î≤ï:</strong><br>
                            1. Îçî Ïò§Îûò ÎÖπÏùåÌïòÍ∏∞ (3Ï¥à Ïù¥ÏÉÅ)<br>
                            2. Îã§Î•∏ Î∏åÎùºÏö∞Ï†Ä ÏãúÎèÑ<br>
                            3. ÌååÏùº ÏóÖÎ°úÎìú Î∞©Ïãù ÏÇ¨Ïö©
                        </p>
                    </div>
                `;
                
                const container = document.querySelector('.container');
                const existingDebug = container.querySelector('.debug-info');
                if (existingDebug) {
                    existingDebug.remove();
                }
                
                const debugDiv = document.createElement('div');
                debugDiv.className = 'debug-info';
                debugDiv.innerHTML = debugInfo;
                container.appendChild(debugDiv);
            }
            
            clearAll() {
                document.getElementById('resultsSection').classList.add('hidden');
                document.getElementById('fileInput').value = '';
                this.updateStatus('Ïò§ÎîîÏò§ ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌïòÍ±∞ÎÇò Ïã§ÏãúÍ∞Ñ ÎÖπÏùåÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî.', 'ready');
                
                // ÌååÌòï Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
                this.waveformData = null;
                this.waveformSampleRate = 44100;
                this.scrollOffset = 0;
                this.zoomLevel = 1;
                
        
                
                // Í∞íÎì§ Ï¥àÍ∏∞Ìôî
                const elements = ['resonantFreq', 'qFactor', 'harmonicRatio', 'decayCoeff', 'halfLife', 'rSquared', 'maxAmplitude', 'duration', 'snr', 'freqMatch', 'decayPattern', 'totalScore'];
                elements.forEach(id => {
                     document.getElementById(id).textContent = '--';
                });
            }
            
            updateStatus(message, type) {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status status-${type}`;
            }
        }
        
        // Ïï± Ï¥àÍ∏∞Ìôî
        document.addEventListener('DOMContentLoaded', () => {
            new OfflineMaterialAnalyzer();
        });
    </script>
</body>
</html>