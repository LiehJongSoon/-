<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>재질 공명 분석기 - 차트 개선 버전</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Malgun Gothic', '맑은 고딕', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
        }
        
        .input-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #764ba2;
            background: rgba(102, 126, 234, 0.05);
        }
        
        .upload-area.dragover {
            border-color: #764ba2;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }
        
        .upload-icon {
            font-size: 4em;
            color: #667eea;
            margin-bottom: 20px;
            display: block;
        }
        
        .upload-text {
            font-size: 1.3em;
            color: #2c3e50;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .upload-subtext {
            color: #7f8c8d;
            font-size: 1em;
        }
        
        .file-input {
            display: none;
        }
        
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 10px;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
            color: white;
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(149, 165, 166, 0.4);
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .chart-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .chart-canvas {
            width: 100%;
            height: 300px;
            border: 1px solid #ecf0f1;
            border-radius: 10px;
        }
        
        .results {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            grid-column: 1 / -1;
        }
        
        .results-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .material-prediction {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .predicted-material {
            font-size: 2em;
            font-weight: bold;
            padding: 15px 30px;
            border-radius: 15px;
            color: white;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: none;
        }
        
        .material-wood { background: linear-gradient(45deg, #8b4513, #a0522d); }
        .material-ceramic { background: linear-gradient(45deg, #f39c12, #e67e22); }
        .material-iron { background: linear-gradient(45deg, #95a5a6, #7f8c8d); }
        .material-aluminum { background: linear-gradient(45deg, #3498db, #2980b9); }
        
        .confidence {
            font-size: 1.2em;
            color: #2c3e50;
            display: none;
        }
        
        .analysis-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .detail-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border-left: 5px solid #667eea;
        }
        
        .detail-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .detail-value {
            font-size: 1.1em;
            color: #34495e;
            margin-bottom: 5px;
        }
        
        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        
        .status-ready {
            background: #d5f4e6;
            color: #27ae60;
        }
        
        .status-analyzing {
            background: #74b9ff;
            color: #0984e3;
        }
        
        .status-complete {
            background: #fd79a8;
            color: #e84393;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .analysis-grid {
                grid-template-columns: 1fr;
            }
            
            .analysis-details {
                grid-template-columns: 1fr;
            }
            
            .material-prediction {
                flex-direction: column;
            }
        }
        
        .realtime-section {
            background: #fff3cd;
            border: 2px solid #ffeaa7;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .realtime-title {
            color: #856404;
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .realtime-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn-record {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }
        
        .btn-record:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
        }
        
        .btn-record.recording {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            animation: pulse 1.5s infinite;
        }
        
        .btn-stop {
            background: linear-gradient(45deg, #34495e, #2c3e50);
            color: white;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
#harmonicRatio,
      .detail-value:has(#harmonicRatio) {
          display: none !important;
      }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎵 재질 공명 분석기</h1>
            <p class="subtitle">주파수 분석 + 개선된 감쇠 모델을 통한 정밀 재질 분류 (차트 개선 버전)</p>
        </div>
        
        <div id="status" class="status status-ready">
            오디오 파일을 업로드하거나 실시간 녹음을 시작하세요.
        </div>
        
        <!-- 실시간 녹음 섹션 -->
        <div class="realtime-section">
            <div class="realtime-title">🎤 실시간 분석 (선택사항)</div>
            <p style="color: #856404; margin-bottom: 15px;">마이크가 지원되는 환경에서 실시간 분석을 시도할 수 있습니다.</p>
            <div class="realtime-buttons">
                <button id="recordBtn" class="btn btn-record">🎤 실시간 녹음</button>
                <button id="stopBtn" class="btn btn-stop">⏹️ 중지</button>
            </div>
        </div>
        
        <!-- 파일 업로드 섹션 -->
        <div class="input-section">
            <div class="upload-area" id="uploadArea">
                <span class="upload-icon">📁</span>
                <div class="upload-text">오디오 파일을 여기에 드래그하거나 클릭하세요</div>
                <div class="upload-subtext">지원 형식: MP3, WAV, M4A, OGG (최대 10MB)</div>
            </div>
            <input type="file" id="fileInput" class="file-input" accept="audio/*">
            <button id="uploadBtn" class="btn btn-primary">📂 파일 선택</button>
            <button id="clearBtn" class="btn btn-secondary">🗑️ 초기화</button>
        </div>
        
        <!-- 분석 결과 섹션 -->
        <div id="resultsSection" class="hidden">
            <div class="analysis-grid">
                <div class="chart-container">
                    <div class="chart-title">📈 시간 영역 파형<br> 
<small>x축: 시간(s) / y축: 진폭 (–1~+1, norm. PCM)</small></div>
                    <canvas id="waveformChart" class="chart-canvas"></canvas>
                </div>
                
                <div class="chart-container">
                    <div class="chart-title">🌊 주파수 스펙트럼</div>
                    <canvas id="spectrumChart" class="chart-canvas"></canvas>
                </div>
            </div>
            
            <div class="results">
                <div class="results-title">🔬 분석 결과(모달 파라미터)</div>
                             
     
                <div class="analysis-details">
                    <div class="detail-card">
                        <div class="detail-title">🎵 주파수 분석</div>
                        <div class="detail-value">주요 공명 주파수: <span id="resonantFreq">-- Hz</span></div>
                        <div class="detail-value">Q-Factor: <span id="qFactor">--</span></div>
                        <div class="detail-value">하모닉 비율: <span id="harmonicRatio">--%</span></div>
                    </div>
                    
                    <div class="detail-card">
                        <div class="detail-title">📉 감쇠 분석</div>
                        <div class="detail-value">감쇠 계수: <span id="decayCoeff">-- /s</span></div>
                        <div class="detail-value">반감기: <span id="halfLife">-- s</span></div>
                        <div class="detail-value">R² 값: <span id="rSquared">--</span></div>
                    </div>
                    
                    <div class="detail-card">
                        <div class="detail-title">🔊 신호 특성</div>
                        <div class="detail-value">최대 진폭: <span id="maxAmplitude">-- dB</span></div>
                        <div class="detail-value">지속 시간: <span id="duration">-- s</span></div>
                        <div class="detail-value">신호 대 잡음비: <span id="snr">-- dB</span></div>
                    </div>
                    
<div class="detail-card">
    <div class="detail-title">📈 포락선 분석</div>
    <canvas id="envelopeChart" style="width: 100%; height: 200px; border: 1px solid #ecf0f1; border-radius: 5px;"></canvas>
    <div style="font-size: 0.9em; color: #7f8c8d; margin-top: 5px; text-align: center;">
       감쇠 포락선 — <span id="envelopeInfo">—</span>
    </div>
</div>
                    
                </div>
            </div>
        </div>
    </div>

    <script>
        class OfflineMaterialAnalyzer {
            constructor() {
                this.audioContext = null;
                this.isRecording = false;
                this.audioData = [];
                this.sampleRate = 44100;
                this.currentStream = null;
                this.isCountingDown = false;
this.countdownInterval = null;

                // 파형 스크롤 관련 변수
                this.waveformData = null;
                this.waveformSampleRate = 44100;
                this.scrollOffset = 0; // 스크롤 오프셋 (초 단위)
                this.zoomLevel = 1; // 줌 레벨 (1 = 전체, 2 = 2배 확대)
                this.isDragging = false;
                this.lastMouseX = 0;
                
                // 재질별 특성 데이터베이스
                this.materialDatabase = {
                    wood: {
                        resonantFreq: [200, 400, 800],
                        qFactor: [5, 15],
                        decayCoeff: [2, 8],
                        harmonicPattern: 'rich_low',
                        name: '나무',
                        class: 'material-wood'
                    },
                    ceramic: {
                        resonantFreq: [800, 1600, 3200],
                        qFactor: [15, 40],
                        decayCoeff: [1, 4],
                        harmonicPattern: 'clear_high',
                        name: '도자기',
                        class: 'material-ceramic'
                    },
                    iron: {
                        resonantFreq: [400, 1200, 2400],
                        qFactor: [20, 60],
                        decayCoeff: [0.5, 3],
                        harmonicPattern: 'metallic',
                        name: '철',
                        class: 'material-iron'
                    },
                    aluminum: {
                        resonantFreq: [600, 1800, 3600],
                        qFactor: [25, 80],
                        decayCoeff: [0.3, 2],
                        harmonicPattern: 'bright_metallic',
                        name: '알루미늄',
                        class: 'material-aluminum'
                    }
                };
                
                this.initializeEvents();
            }
            
            initializeEvents() {
                // 파일 업로드 이벤트
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const uploadBtn = document.getElementById('uploadBtn');
                const clearBtn = document.getElementById('clearBtn');
                
                // 실시간 녹음 이벤트
                const recordBtn = document.getElementById('recordBtn');
                const stopBtn = document.getElementById('stopBtn');
                
                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
                uploadArea.addEventListener('drop', this.handleDrop.bind(this));
                
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));
                uploadBtn.addEventListener('click', () => fileInput.click());
                clearBtn.addEventListener('click', this.clearAll.bind(this));
                
                recordBtn.addEventListener('click', this.startRealTimeRecording.bind(this));
                stopBtn.addEventListener('click', this.stopRealTimeRecording.bind(this));
                
                // 파형 차트 스크롤 이벤트 추가
                this.initializeWaveformEvents();
            }
            
            initializeWaveformEvents() {
                const canvas = document.getElementById('waveformChart');
                
                // 마우스 드래그 이벤트
                canvas.addEventListener('mousedown', this.onWaveformMouseDown.bind(this));
                canvas.addEventListener('mousemove', this.onWaveformMouseMove.bind(this));
                canvas.addEventListener('mouseup', this.onWaveformMouseUp.bind(this));
                canvas.addEventListener('mouseleave', this.onWaveformMouseUp.bind(this));
                
                // 마우스 휠 이벤트 (줌)
                canvas.addEventListener('wheel', this.onWaveformWheel.bind(this));
                
                // 더블클릭으로 리셋
                canvas.addEventListener('dblclick', this.resetWaveformView.bind(this));
                
// 터치(핀치) 이벤트
canvas.addEventListener('touchstart', this.onWaveformTouchStart.bind(this), { passive: false });
canvas.addEventListener('touchmove',  this.onWaveformTouchMove.bind(this),  { passive: false });
canvas.addEventListener('touchend',   this.onWaveformTouchEnd.bind(this),   { passive: false });

// 한 손가락 드래그 스크롤
canvas.addEventListener('touchstart', this.onWaveformPanStart.bind(this), { passive: false });
canvas.addEventListener('touchmove',  this.onWaveformPanMove.bind(this),  { passive: false });
canvas.addEventListener('touchend',   this.onWaveformPanEnd.bind(this),   { passive: false });


                // 커서 스타일 설정
                canvas.style.cursor = 'grab';
            }
            
            onWaveformMouseDown(e) {
                this.isDragging = true;
                this.lastMouseX = e.offsetX;
                e.target.style.cursor = 'grabbing';
            }
            
            onWaveformMouseMove(e) {
                if (!this.isDragging || !this.waveformData) return;
                
                const deltaX = e.offsetX - this.lastMouseX;
                const canvas = document.getElementById('waveformChart');
                const timePerPixel = (this.waveformData.length / this.waveformSampleRate) / (canvas.width * this.zoomLevel);
                
                // 스크롤 오프셋 업데이트
                this.scrollOffset -= deltaX * timePerPixel;
                
                // 범위 제한
                const maxDuration = this.waveformData.length / this.waveformSampleRate;
                const viewDuration = maxDuration / this.zoomLevel;
                this.scrollOffset = Math.max(0, Math.min(maxDuration - viewDuration, this.scrollOffset));
                
                this.lastMouseX = e.offsetX;
                this.redrawWaveform();
            }
            
            onWaveformMouseUp(e) {
                this.isDragging = false;
                e.target.style.cursor = 'grab';
            }
            
            onWaveformWheel(e) {
                e.preventDefault();
                if (!this.waveformData) return;
                
                const canvas = document.getElementById('waveformChart');
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                
                // 줌 레벨 조정
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoomLevel = Math.max(1, Math.min(1000, this.zoomLevel * zoomFactor));
                
                // 마우스 위치를 중심으로 줌
                const maxDuration = this.waveformData.length / this.waveformSampleRate;
                const viewDuration = maxDuration / this.zoomLevel;
                const mouseTimeRatio = mouseX / canvas.width;
                const mouseTime = this.scrollOffset + viewDuration * mouseTimeRatio;
                
                this.zoomLevel = newZoomLevel;
                const newViewDuration = maxDuration / this.zoomLevel;
                this.scrollOffset = mouseTime - newViewDuration * mouseTimeRatio;
                
                // 범위 제한
                this.scrollOffset = Math.max(0, Math.min(maxDuration - newViewDuration, this.scrollOffset));
                
                this.redrawWaveform();
            }
          
onWaveformTouchStart(e) {
    if (!this.waveformData) return;
    if (e.touches.length === 2) {
        // 두 손가락 사이 초기 거리 & 중심 X 저장
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        this._pinchDist = Math.hypot(dx, dy);

        const canvas = document.getElementById('waveformChart');
        const rect = canvas.getBoundingClientRect();
        const cx = (e.touches[0].clientX + e.touches[1].clientX) * 0.5 - rect.left;
        this._pinchCenterX = Math.max(0, Math.min(canvas.width, cx));
        e.preventDefault();
    }
}

onWaveformTouchMove(e) {
    if (!this.waveformData) return;
    if (e.touches.length === 2 && this._pinchDist) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.hypot(dx, dy);

        // 마우스 휠 줌과 동일한 로직: 중심 고정 줌
        const canvas = document.getElementById('waveformChart');
        const maxDuration = this.waveformData.length / this.waveformSampleRate;

        // 한 번의 move마다 배율 비
        const zoomFactor = dist / this._pinchDist;
        this._pinchDist = dist;

        // 새 줌레벨 (바운드 동일)
        const newZoom = Math.max(1, Math.min(1000, this.zoomLevel * zoomFactor));

        // 중심 위치를 기준으로 시간축 보정
        const mouseTimeRatio = this._pinchCenterX / canvas.width;
        const viewDuration   = maxDuration / this.zoomLevel;
        const anchorTime     = this.scrollOffset + viewDuration * mouseTimeRatio;

        this.zoomLevel = newZoom;

        const newViewDuration = maxDuration / this.zoomLevel;
        this.scrollOffset = anchorTime - newViewDuration * mouseTimeRatio;

        // 범위 제한
        this.scrollOffset = Math.max(0, Math.min(maxDuration - newViewDuration, this.scrollOffset));

        this.redrawWaveform();
        e.preventDefault();
    }
}

onWaveformTouchEnd(e) {
    if (e.touches.length < 2) {
        this._pinchDist = null;
    }
}

onWaveformPanStart(e) {
    if (!this.waveformData) return;
    if (e.touches.length === 1) {
        this._panLastX = e.touches[0].clientX;
    }
}

onWaveformPanMove(e) {
    if (!this.waveformData) return;
    if (e.touches.length === 1 && this._panLastX != null) {
        const canvas = document.getElementById('waveformChart');
        const maxDuration = this.waveformData.length / this.waveformSampleRate;
        const viewDuration = maxDuration / this.zoomLevel;

        // 이동량(px → 시간 단위로 환산)
        const dx = e.touches[0].clientX - this._panLastX;
        const dt = -dx / canvas.width * viewDuration;

        this.scrollOffset = Math.max(0, Math.min(maxDuration - viewDuration, this.scrollOffset + dt));
        this._panLastX = e.touches[0].clientX;

        this.redrawWaveform();
        e.preventDefault();
    }
}

onWaveformPanEnd(e) {
    if (e.touches.length === 0) {
        this._panLastX = null;
    }
}
 
            resetWaveformView() {
                this.scrollOffset = 0;
                this.zoomLevel = 1;
                this.redrawWaveform();
            }
            
            redrawWaveform() {
                if (!this.waveformData) return;
                this.drawScrollableWaveform(this.waveformData, this.waveformSampleRate);
            }
            
            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.add('dragover');
            }
            
            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
            }
            
            handleDrop(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.processFile(files[0]);
                }
            }
            
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.processFile(file);
                }
            }
            
            async processFile(file) {
                if (!file.type.startsWith('audio/')) {
                    this.updateStatus('오디오 파일만 업로드 가능합니다.', 'error');
                    return;
                }
                
                if (file.size > 10 * 1024 * 1024) {
                    this.updateStatus('파일 크기가 10MB를 초과합니다.', 'error');
                    return;
                }
                
                this.updateStatus('파일을 분석하고 있습니다...', 'analyzing');
                
                try {
                    const audioBuffer = await this.loadAudioFile(file);
                    await this.analyzeAudioBuffer(audioBuffer);
                } catch (error) {
                    console.error('파일 처리 오류:', error);
                    this.updateStatus('파일 처리 중 오류가 발생했습니다.', 'error');
                }
            }
            
            async loadAudioFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            const audioBuffer = await audioContext.decodeAudioData(e.target.result);
                            resolve(audioBuffer);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }
            
            async analyzeAudioBuffer(audioBuffer) {
                try {
                    console.log('오디오 버퍼 분석 시작...');
                    
                    // 오디오 데이터 추출
                    const channelData = audioBuffer.getChannelData(0);
                    const sampleRate = audioBuffer.sampleRate;
                    const duration = audioBuffer.duration;
                    
                    console.log('오디오 정보:', {
                        samples: channelData.length,
                        sampleRate,
                        duration
                    });
                    
                    // 간단한 분석만 수행 (스택 오버플로우 방지)
                    const analysis = this.performSimpleAnalysis(channelData, sampleRate);
                    
                    // 결과 표시
                    this.displaySimpleResults(analysis, channelData, sampleRate);
                    
                    // 개선된 차트 그리기
                    setTimeout(() => {
                        // 파형 데이터 저장 (스크롤용)
                        this.waveformData = channelData;
                        this.waveformSampleRate = sampleRate;
                        this.scrollOffset = 0;
                        this.zoomLevel = 1;
                        
                        this.drawScrollableWaveform(channelData, sampleRate);
                        this.drawRealSpectrum(analysis.spectrum, analysis.freqBins || [], sampleRate);
                    }, 100);
                    
                    document.getElementById('resultsSection').classList.remove('hidden');
                    this.updateStatus('분석이 완료되었습니다!', 'complete');
                    


                } catch (error) {
                    console.error('분석 중 오류:', error);
                    this.updateStatus(`분석 중 오류: ${error.message}`, 'error');
                }
            }

            
calculateQFactor(powerSpectrum, freqBins, dominantFreq) {
    try {
        console.log('Q-Factor 계산 시작:', dominantFreq);
        
        // 주요 피크 인덱스 찾기
        let peakIndex = -1;
        let peakMagnitude = 0;
        
                // 주요 피크 인덱스 찾기 (고정폭 사용 금지: dominantFreq에 가장 가까운 빈 선택)
peakIndex = 0;                                   // ← 'let' 삭제 (기존 선언 재사용)
peakMagnitude = powerSpectrum[0] || 0;           // ← 'let' 삭제 (기존 선언 재사용)
let minDiff = Infinity;
for (let i = 0; i < powerSpectrum.length && i < freqBins.length; i++) {
    const d = Math.abs(freqBins[i] - dominantFreq);
    if (d < minDiff) {
        minDiff = d;
        peakIndex = i;
        peakMagnitude = powerSpectrum[i];
    }
}
console.log('피크 인덱스:', peakIndex, '피크 크기:', peakMagnitude);
if (peakIndex === -1) return NaN;



// 포물선 보간 함수
function parabolicInterpolation(y1, y2, y3) {
    const a = (y1 - 2*y2 + y3) / 2;
    const b = (y3 - y1) / 2;
    if (Math.abs(a) < 1e-10) return { xOffset: 0, yPeak: y2 };
    const xOffset = -b / (2*a);
    const yPeak = y2 - b*b/(4*a);
    return { xOffset, yPeak };
}

// 피크 보간 적용
let correctedFreq = dominantFreq;
let correctedMagnitude = peakMagnitude;

if (peakIndex > 0 && peakIndex < powerSpectrum.length - 1) {
    const interp = parabolicInterpolation(
        powerSpectrum[peakIndex-1],
        powerSpectrum[peakIndex], 
        powerSpectrum[peakIndex+1]
    );
    
    const binWidth = freqBins.length > 1 ? (freqBins[1] - freqBins[0]) : 10;
    correctedFreq = freqBins[peakIndex] + interp.xOffset * binWidth;
    correctedMagnitude = Math.max(0, interp.yPeak);

    
    console.log('보간 전 주파수:', freqBins[peakIndex]);
    console.log('보간 후 주파수:', correctedFreq);
    console.log('보간 전 크기:', peakMagnitude);
    console.log('보간 후 크기:', correctedMagnitude);
}
// 정확한 -3dB 지점 찾기 함수
function findExact3dBPoint(spectrum, freqBins, peakIndex, threshold, direction) {
    let idx = peakIndex;
    const binWidth = freqBins.length > 1 ? (freqBins[1] - freqBins[0]) : 10;
    
    while (idx > 0 && idx < spectrum.length - 1) {
        idx += direction;
        if (spectrum[idx] <= threshold) {
            if (idx - direction >= 0 && idx - direction < spectrum.length) {
                // 선형 보간으로 정확한 위치 찾기
                const y1 = spectrum[idx - direction];
                const y2 = spectrum[idx];
                const f1 = freqBins[idx - direction] || (freqBins[0] + (idx - direction) * binWidth);
                const f2 = freqBins[idx] || (freqBins[0] + idx * binWidth);
                
                if (Math.abs(y1 - y2) > 1e-10) {
                    const ratio = (threshold - y2) / (y1 - y2);
                    return f2 + ratio * (f1 - f2);
                }
            }
            return freqBins[idx] || (freqBins[0] + idx * binWidth);
        }
    }
    return freqBins[idx] || (freqBins[0] + idx * binWidth);
}

// 보정된 값으로 dominantFreq, peakMagnitude 업데이트
dominantFreq = correctedFreq;
peakMagnitude = correctedMagnitude;        
 this.correctedDominantFreq = correctedFreq;


        // -3dB 지점 찾기 (피크의 70.7% 지점)
        // Power spectrum 기반 정확한 -3dB 계산
const peakPower = peakMagnitude * peakMagnitude;
const halfPowerLevel = Math.sqrt(peakPower * 0.5); // 정확한 -3dB
        
        let leftIndex = peakIndex;
        let rightIndex = peakIndex;
        
        // 왼쪽 -3dB 지점 (선형 보간 적용)
        while (leftIndex > 0 && powerSpectrum[leftIndex] > halfPowerLevel) {
            leftIndex--;
        }
        
        // 오른쪽 -3dB 지점 (선형 보간 적용)
        while (rightIndex < powerSpectrum.length - 1 && powerSpectrum[rightIndex] > halfPowerLevel) {
            rightIndex++;
        }
        
       // 정교한 -3dB 지점 탐지
const f1 = findExact3dBPoint(powerSpectrum, freqBins, peakIndex, halfPowerLevel, -1);
const f2 = findExact3dBPoint(powerSpectrum, freqBins, peakIndex, halfPowerLevel, 1);

console.log('정교한 f1:', f1, 'f2:', f2);
        
       
        
       const bandwidth = f2 - f1;
console.log('f1:', f1, 'f2:', f2, 'bandwidth:', bandwidth);
if (bandwidth <= 0) return NaN;

const qFactor = dominantFreq / bandwidth;
console.log('계산된 Q-Factor:', qFactor);
return qFactor;

        
   } catch (error) {
    console.error('Q-Factor 계산 오류:', error);
    return NaN;
}
}

calculateHarmonicRatio(powerSpectrum, freqBins, dominantFreq) {
    try {
        console.log('하모닉 계산 시작:', dominantFreq);
        if (powerSpectrum.length === 0 || freqBins.length === 0) return 50.0;
        
        // 빈 크기 계산 (적응적 범위를 위해)
        const binWidth = freqBins.length > 1 ? (freqBins[1] - freqBins[0]) : 10;
        const searchRange = Math.max(binWidth * 5, 50); // 더 넓은 범위
        
        // 에너지 제곱 미리 계산 (효율성)
        const energySquared = powerSpectrum.map(val => val * val);
        
        let fundamentalEnergy = 0;
        let harmonicEnergy = 0;
        let totalEnergy = 0;
        
        // 전체 에너지 계산
        for (let i = 0; i < energySquared.length; i++) {
            totalEnergy += energySquared[i];
        }
        
        if (totalEnergy === 0) return 50.0;
        
        // 사용된 빈 추적 (중복 방지)
        const usedBins = new Set();
        
        // 기본 주파수 에너지
        for (let i = 0; i < freqBins.length; i++) {
            if (Math.abs(freqBins[i] - dominantFreq) <= searchRange) {
                fundamentalEnergy += energySquared[i];
                usedBins.add(i);
            }
        }
        
        // 하모닉 에너지 (2차~5차, 중복 방지)
        for (let harmonic = 2; harmonic <= 5; harmonic++) {
            const harmonicFreq = dominantFreq * harmonic;
            
            for (let i = 0; i < freqBins.length; i++) {
                if (!usedBins.has(i) && Math.abs(freqBins[i] - harmonicFreq) <= searchRange) {
                    harmonicEnergy += energySquared[i];
                    usedBins.add(i); // 중복 방지
                }
            }
        }
        
       // 하모닉 비율 계산
        console.log('기본파 에너지:', fundamentalEnergy, '하모닉 에너지:', harmonicEnergy, '전체 에너지:', totalEnergy);
        const harmonicRatio = (harmonicEnergy / totalEnergy) * 100;
        console.log('계산된 하모닉 비율:', harmonicRatio);
        return Math.max(0, Math.min(100, harmonicRatio));
        
    } catch (error) {
        console.error('하모닉 비율 계산 오류:', error);
        return 50.0;
    }
}
            performSimpleAnalysis(channelData, sampleRate) {
                console.log('간단한 분석 시작...');
                
                try {
                    // 1. 기본 통계
                    const maxAmplitude = this.safeMax(channelData.map(Math.abs));
                    const rms = this.safeRMS(channelData);
                    
                    // 2. 피크 탐지
                    const peakIdx = this.safeFindMax(channelData);
                    const peakTime = peakIdx / sampleRate;
                    
                    // 3. 실제 FFT를 사용한 주파수 분석
                    const frequencyAnalysis = this.performFFTAnalysis(channelData, sampleRate);
                    const dominantFreq = frequencyAnalysis.dominantFreq;
                    const spectrum = frequencyAnalysis.spectrum;
                    
                    // 4. 간단한 감쇠 추정
                    const decayInfo = this.estimateSimpleDecay(channelData, peakIdx, sampleRate);
                    
                    // 5. 재질 분류 (간단한 규칙 기반)
                    const material = this.classifyMaterialSimple(dominantFreq, decayInfo.halfLife, maxAmplitude);
                    
               return {
    maxAmplitude,
    rms,
    peakIdx,
    peakTime,
    dominantFreq,
    qFactor: frequencyAnalysis.qFactor,
    harmonicRatio: frequencyAnalysis.harmonicRatio,

    // 감쇠 결과 (+ 신뢰도)
    decayCoeff: decayInfo.decay,
    halfLife: decayInfo.halfLife,
    rSquared: decayInfo.rSquared,
    rho: (Number.isFinite(decayInfo.rho) ? decayInfo.rho : null),

    // 시각화용 창/회귀 정보
    decayVis: (decayInfo.vis || null),

    // 기타
    duration: channelData.length / sampleRate,
    material,
    spectrum,
    freqBins: frequencyAnalysis.freqBins || []
};

                    
                } catch (error) {
                    console.error('간단한 분석 오류:', error);
                    return this.getDefaultAnalysis();
                }
            }
            
            performFFTAnalysis(channelData, sampleRate) {
                try {
                    console.log('FFT 분석 시작...');
                    
                    // FFT 크기 결정 (2의 거듭제곱)
                    let fftSize = 1024;
                    while (fftSize < channelData.length && fftSize < 8192) {
                        fftSize *= 2;
                    }
                    fftSize = Math.min(fftSize, 16384); // 최대 16384로 증가
                    
                    // 윈도우 함수 적용할 데이터 추출
                    const windowedData = this.applyHannWindow(channelData, fftSize);
                    
                    // FFT 계산
                    const fftResult = this.computeFFT(windowedData);
                    
                    // 파워 스펙트럼 계산
                    const powerSpectrum = this.computePowerSpectrum(fftResult);
                    
                    // 주파수 빈 계산
                    const freqBins = [];
                    for (let i = 0; i < powerSpectrum.length; i++) {
                        freqBins.push((i * sampleRate) / (2 * powerSpectrum.length));
                    }
                    
                    // 주요 주파수 찾기
                    const dominantFreq = this.findDominantFrequency(powerSpectrum, freqBins);
                    
                    console.log('FFT 분석 완료:', {
                        fftSize,
                        dominantFreq,
                        spectrumLength: powerSpectrum.length
                    });
                    
                   // 추가 분석 수행
const qFactor = this.calculateQFactor(powerSpectrum, freqBins, dominantFreq);
const refinedF0 = (this.correctedDominantFreq || dominantFreq);
const harmonicRatio = this.calculateHarmonicRatio(powerSpectrum, freqBins, refinedF0);

return {
    spectrum: powerSpectrum,
    dominantFreq: refinedF0,
    freqBins,
    qFactor,
    harmonicRatio
};
                    
                } catch (error) {
                    console.error('FFT 분석 오류:', error);
                    // 폴백: 간단한 스펙트럼
                    return {
                        spectrum: this.createSimpleSpectrum(channelData, 440),
                        dominantFreq: 440,
                        freqBins: []
                    };
                }
            }
            
            applyHannWindow(data, fftSize) {
                // 데이터에서 가장 에너지가 높은 부분 찾기
                const windowSize = Math.min(fftSize, data.length);
                let maxEnergy = 0;
                let bestStart = 0;
                
                const hopSize = Math.floor(windowSize / 4);
                for (let start = 0; start <= data.length - windowSize; start += hopSize) {
                    let energy = 0;
                    for (let i = 0; i < windowSize; i++) {
                        energy += data[start + i] * data[start + i];
                    }
                    if (energy > maxEnergy) {
                        maxEnergy = energy;
                        bestStart = start;
                    }
                }
                
                // 해당 구간에 Hann 윈도우 적용
                const windowed = new Array(fftSize).fill(0);
                for (let i = 0; i < windowSize; i++) {
                    const hannValue = 0.5 * (1 - Math.cos(2 * Math.PI * i / (windowSize - 1)));
                    windowed[i] = (data[bestStart + i] || 0) * hannValue;
                }
                
                return windowed;
            }
            
            computeFFT(data) {
                const N = data.length;
                
                // 간단한 DFT 구현 (작은 크기용)
                if (N <= 512) {
                    return this.computeDFT(data);
                }
                
                // 큰 크기는 간단한 FFT
                return this.computeSimpleFFT(data);
            }
            
            computeDFT(data) {
                const N = data.length;
                const result = [];
                
                for (let k = 0; k < N / 2; k++) { // 나이퀴스트 주파수까지만
                    let realSum = 0;
                    let imagSum = 0;
                    
                    for (let n = 0; n < N; n++) {
                        const angle = -2 * Math.PI * k * n / N;
                        realSum += data[n] * Math.cos(angle);
                        imagSum += data[n] * Math.sin(angle);
                    }
                    
                    result.push({ real: realSum, imag: imagSum });
                }
                
                return result;
            }
            
            computeSimpleFFT(data) {
                // 매우 간단한 FFT (교육용)
                const N = data.length;
                if (N <= 1) return [{ real: data[0] || 0, imag: 0 }];
                
                // 재귀 대신 DFT 사용 (안전성)
                return this.computeDFT(data);
            }
            
            computePowerSpectrum(fftResult) {
                const powerSpectrum = [];
                
                for (let i = 0; i < fftResult.length; i++) {
                    const real = fftResult[i].real;
                    const imag = fftResult[i].imag;
                    const magnitude = Math.sqrt(real * real + imag * imag);
                    powerSpectrum.push(magnitude);
                }
                
                // 정규화
                const maxMagnitude = Math.max(...powerSpectrum);
                if (maxMagnitude > 0) {
                    for (let i = 0; i < powerSpectrum.length; i++) {
                        powerSpectrum[i] /= maxMagnitude;
                    }
                }
                
                return powerSpectrum;
            }
            
            findDominantFrequency(powerSpectrum, freqBins) {
                let maxMagnitude = 0;
                let dominantFreq = 0;
                
                // 20Hz ~ 5000Hz 범위에서 찾기
                for (let i = 0; i < powerSpectrum.length && i < freqBins.length; i++) {
                    const freq = freqBins[i];
                    if (freq >= 20 && freq <= 5000 && powerSpectrum[i] > maxMagnitude) {
                        maxMagnitude = powerSpectrum[i];
                        dominantFreq = freq;
                    }
                }
                
                return dominantFreq || 440; // 기본값
            }
            
            createSimpleSpectrum(channelData, dominantFreq) {
                // 폴백용 간단한 스펙트럼
                const spectrum = new Array(128).fill(0);
                
                try {
                    const centerBin = Math.floor((dominantFreq / 2000) * spectrum.length);
                    
                    if (centerBin >= 0 && centerBin < spectrum.length) {
                        spectrum[centerBin] = 1.0;
                    }
                    
                    // 하모닉스
                    for (let harmonic = 2; harmonic <= 5; harmonic++) {
                        const harmonicBin = Math.floor(centerBin * harmonic);
                        if (harmonicBin < spectrum.length) {
                            spectrum[harmonicBin] = 1.0 / harmonic;
                        }
                    }
                    
                    // 노이즈 플로어
                    for (let i = 0; i < spectrum.length; i++) {
                        spectrum[i] += Math.random() * 0.05;
                    }
                    
                    return spectrum;
                    
                } catch (error) {
                    spectrum[32] = 1.0;
                    return spectrum;
                }
            }
            
            safeMax(array) {
                if (!array || array.length === 0) return 0;
                let max = array[0];
                for (let i = 1; i < array.length; i++) {
                    if (array[i] > max) max = array[i];
                }
                return max;
            }
            
            safeRMS(array) {
                if (!array || array.length === 0) return 0;
                let sum = 0;
                for (let i = 0; i < array.length; i++) {
                    sum += array[i] * array[i];
                }
                return Math.sqrt(sum / array.length);
            }
            
            safeFindMax(array) {
                if (!array || array.length === 0) return 0;
                let maxIdx = 0;
                let maxVal = Math.abs(array[0]);
                for (let i = 1; i < array.length; i++) {
                    const val = Math.abs(array[i]);
                    if (val > maxVal) {
                        maxVal = val;
                        maxIdx = i;
                    }
                }
                return maxIdx;
            }
            
            estimateFrequencyZeroCrossing(data, sampleRate) {
                try {
                    let crossings = 0;
                    const maxSamples = Math.min(data.length, 10000); // 제한
                    
                    for (let i = 1; i < maxSamples; i++) {
                        if ((data[i-1] >= 0 && data[i] < 0) || (data[i-1] < 0 && data[i] >= 0)) {
                            crossings++;
                        }
                    }
                    
                    const frequency = (crossings / 2) * (sampleRate / maxSamples);
                    return Math.min(Math.max(frequency, 50), 5000); // 50Hz ~ 5kHz 제한
                } catch (error) {
                    console.error('주파수 추정 오류:', error);
                    return 440; // 기본값
                }
            }
            
          
estimateSimpleDecay(data, peakIdx, sampleRate) {
    try {
        // 0) 준비
        const after = data.slice(peakIdx);
        const N = after.length;
        if (N < 32) {
            return { decay: 0, halfLife: 0, rSquared: 0, rho: Infinity, vis: null };
        }

        // 1) 시간영역 평균주기 추정 (FFT f0 사용하지 않음)
        function estimatePeriodFrames(x) {
            const M = Math.min(x.length, 8192);
            if (M < 32) return null;
            const y = x.slice(0, M);
            // DC 제거
            const mu = y.reduce((a, b) => a + b, 0) / M;
            for (let i = 0; i < M; i++) y[i] -= mu;

            // 1..M/2 래그에서 자기상관(편향보정) 최대 지점
            let bestLag = 0, bestVal = -1e99;
            const denom0 = y.reduce((s, v) => s + v * v, 0) + 1e-12;
            for (let lag = 1; lag <= Math.floor(M / 2); lag++) {
                let acc = 0;
                for (let i = 0; i < M - lag; i++) acc += y[i] * y[i + lag];
                // 편향보정
                const val = acc / (M - lag);
                if (val > bestVal) { bestVal = val; bestLag = lag; }
            }
            if (bestLag <= 1) return null;
            // 최소 2프레임 보장
            return Math.max(2, bestLag);
        }

        // 2) 포락선(윈도우-최대치) 생성 함수 (원본 방식과 동일 계열: 구간 최대치)
        function buildEnvelopeMaxAbs(x, w) {
            const L = Math.floor(x.length / w);
            const env = new Array(L);
            for (let i = 0; i < L; i++) {
                const s = i * w;
                const e = Math.min(s + w, x.length);
                let m = 0;
                for (let k = s; k < e; k++) {
                    const a = Math.abs(x[k]);
                    if (a > m) m = a;
                }
                env[i] = m + 1e-12; // log 안정
            }
            return env;
        }

        // 3) 선형회귀(y = a + b t) 도우미: slope b, intercept a, R², SE(b)
        function linreg(t, y) {
            const n = y.length;
            if (n < 3) return null;
            let sx = 0, sy = 0, sxx = 0, sxy = 0, syy = 0;
            for (let i = 0; i < n; i++) {
                sx += t[i]; sy += y[i];
                sxx += t[i] * t[i];
                sxy += t[i] * y[i];
                syy += y[i] * y[i];
            }
            const mx = sx / n, my = sy / n;
            const den = sxx - n * mx * mx + 1e-12;
            const b = (sxy - n * mx * my) / den;
            const a = my - b * mx;

            // R²
            let ssRes = 0, ssTot = 0;
            for (let i = 0; i < n; i++) {
                const yhat = a + b * t[i];
                ssRes += (y[i] - yhat) * (y[i] - yhat);
                ssTot += (y[i] - my) * (y[i] - my);
            }
            const r2 = 1 - ssRes / (ssTot + 1e-12);

            // SE(b)
            const sigma2 = ssRes / Math.max(1, (n - 2));
            const se_b = Math.sqrt(sigma2 / (den + 1e-12));
            return { a, b, r2, se_b };
        }

        // 4) 평활 윈도우 후보 (데이터 상대 기준)
        const T_hat_frames = estimatePeriodFrames(after); // f0 불사용
        const winCandidates = new Set();
        if (Number.isFinite(T_hat_frames)) {
            // 주기 비율 기반 후보 (상수 시간 없음, 비율만 사용)
            [0.5, 0.75, 1.0, 1.25].forEach(r => {
                const w = Math.max(3, Math.floor(T_hat_frames * r));
                if (w < N / 5) winCandidates.add(w);
            });
        }
        if (winCandidates.size === 0) {
            // 레코드 길이에 대한 비율 후보 (절대시간 없음)
            const L = N;
            [200, 160, 120, 100, 80].forEach(div => {
                const w = Math.max(3, Math.floor(L / div));
                if (w < L / 5) winCandidates.add(w);
            });
        }
        const winList = Array.from(winCandidates).sort((a, b) => a - b);
        if (winList.length === 0) return { decay: 0, halfLife: 0, rSquared: 0, rho: Infinity, vis: null };

        // 5) “시작·종료 동시 스캔” + “ρ = SE(b)/|b| 최소” 한 창 선택
        let best = { rho: Infinity, b: 0, a: 0, r2: 0, w: 0, s: 0, e: 0 };
        const peakTime = peakIdx / sampleRate;

        for (const w of winList) {
            const env = buildEnvelopeMaxAbs(after, w);            // 포락선(윈도우-최대)
            const M = env.length;
            if (M < 6) continue;

            // 후보 그리드(데이터 상대): 시작/종료를 균등 분할로 생성
            const stepS = Math.max(1, Math.floor(Math.sqrt(M)));  // 해상도: √M
            const minLen = Math.max(3, Math.floor(M / 20));       // 최소 길이: 전체의 5%
            for (let s = 0; s <= M - minLen; s += stepS) {
                const maxE = M - 1;
                const remain = maxE - s + 1;
                if (remain < minLen) break;

                const stepE = Math.max(1, Math.floor(remain / Math.sqrt(remain)));
                for (let e = s + minLen - 1; e <= maxE; e += stepE) {
                    const K = e - s + 1;
                    if (K < 3) continue;

                    // 시간축: after-peak 기준 절대초 단위
                    const t = new Array(K);
                    const y = new Array(K);
                    for (let i = 0; i < K; i++) {
                        const idx = s + i;
                        const tRel = ((idx + 0.5) * w) / sampleRate;   // after-peak에서의 시간
                        t[i] = tRel;
                        y[i] = Math.log(env[idx]);                    // ln(포락선)
                    }

                    const fit = linreg(t, y);
                    if (!fit) continue;
                    const { a, b, r2, se_b } = fit;
                    if (!(b < 0)) continue; // 감쇠만 채택

                    const rho = Math.abs(se_b / (Math.abs(b) + 1e-12));
                    if (rho < best.rho) {
                        best = { rho, b, a, r2, w, s, e };
                    } else if (Math.abs(rho - best.rho) < 1e-6 && (s < best.s)) {
                        // 동률이면 시작이 이른 창 우선 (재현성)
                        best = { rho, b, a, r2, w, s, e };
                    }
                }
            }
        }

        if (!Number.isFinite(best.b) || !(best.b < 0) || !Number.isFinite(best.rho)) {
            return { decay: 0, halfLife: 0, rSquared: 0, rho: Infinity, vis: null };
        }

        const alpha = -best.b;
        const half = Math.log(2) / alpha;
        return {
            decay: alpha,
            halfLife: half,
            rSquared: Math.max(0, Math.min(1, best.r2 || 0)),
            rho: best.rho,
            vis: {
                windowSize: best.w,        // 프레임
                bestStart: best.s,         // 포락선 인덱스(peak 이후 기준)
                bestEnd: best.e,           // 포락선 인덱스(peak 이후 기준)
                regA: best.a,              // ln(포락선) = a + b t
                regB: best.b
            }
        };
    } catch (error) {
        console.error('감쇠 추정 오류:', error);
        return { decay: 0, halfLife: 0, rSquared: 0, rho: Infinity, vis: null };
    }
}

            
            classifyMaterialSimple(frequency, halfLife, amplitude) {
                try {
                    // 매우 간단한 규칙 기반 분류
                    const ampThreshold = 0.1;
                    const freqThreshold = 1000;
                    const decayThreshold = 2.0;
                    
                    if (frequency < 500 && halfLife > decayThreshold) {
                        return { name: '나무', class: 'material-wood', confidence: 75 };
                    } else if (frequency > freqThreshold && halfLife < 1.0) {
                        return { name: '도자기', class: 'material-ceramic', confidence: 70 };
                    } else if (frequency > 600 && halfLife < decayThreshold && amplitude > ampThreshold) {
                        return { name: '알루미늄', class: 'material-aluminum', confidence: 80 };
                    } else {
                        return { name: '철', class: 'material-iron', confidence: 65 };
                    }
                } catch (error) {
                    console.error('분류 오류:', error);
                    return { name: '알 수 없음', class: 'material-wood', confidence: 50 };
                }
            }
            
            getDefaultAnalysis() {
                return {
                    maxAmplitude: 0.1,
                    rms: 0.05,
                    peakIdx: 1000,
                    peakTime: 0.5,
                    dominantFreq: 440,
                    decayCoeff: 1.0,
                    halfLife: 1.0,
                    duration: 2.0,
                    material: { name: '알 수 없음', class: 'material-wood', confidence: 50 },
                    spectrum: new Array(100).fill(0.1)
                };
            }
            
drawEnvelopeChart(channelData, peakIdx, sampleRate, decayVis = null) {
    try {
        const canvas = document.getElementById('envelopeChart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width || 400;
        canvas.height = rect.height || 200;
        
        const width = canvas.width;
        const height = canvas.height;
        
        // 캔버스 초기화
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#f8f9fa';
        ctx.fillRect(0, 0, width, height);
        
        // 피크 이후 데이터
        const afterPeak = channelData.slice(peakIdx);
        const windowSize = Math.floor(sampleRate * 0.01); // 10ms 윈도우
       const maxWindows = Math.floor(afterPeak.length / windowSize);

        
        if (maxWindows < 2) return;
        
        // 포락선 계산
        const envelope = [];
        const timePoints = [];
        
        for (let i = 0; i < maxWindows; i++) {
            const start = i * windowSize;
            const end = Math.min(start + windowSize, afterPeak.length);
            let max = 0;
            
            for (let j = start; j < end; j++) {
                max = Math.max(max, Math.abs(afterPeak[j]));
            }
            
            envelope.push(max);
            timePoints.push((start + windowSize/2) / sampleRate); // 윈도우 중앙 시간
        }
        
        if (envelope.length === 0) return;
        
        // 정규화
        const maxEnv = Math.max(...envelope);
        const normalizedEnv = envelope.map(val => val / maxEnv);
        
        // 포락선 그리기
        ctx.strokeStyle = '#e74c3c';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let i = 0; i < normalizedEnv.length; i++) {
            const x = (i / (normalizedEnv.length - 1)) * (width - 40) + 20;
            const y = height - 30 - (normalizedEnv[i] * (height - 60));
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.stroke();
        
        // 이론적 지수 감쇠 곡선 (비교용)
        const decayRate = Math.log(normalizedEnv[0] / normalizedEnv[normalizedEnv.length-1]) / timePoints[timePoints.length-1];
        
        ctx.strokeStyle = '#3498db';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        
        for (let i = 0; i < normalizedEnv.length; i++) {
            const x = (i / (normalizedEnv.length - 1)) * (width - 40) + 20;
            const theoreticalVal = Math.exp(-decayRate * timePoints[i]);
            const y = height - 30 - (theoreticalVal * (height - 60));
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.stroke();
        ctx.setLineDash([]);
        
        // 축 라벨
        ctx.fillStyle = '#2c3e50';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        
        // 시간 축
        const timeLabels = [0, timePoints[Math.floor(timePoints.length/2)], timePoints[timePoints.length-1]];
        const xPositions = [20, width/2, width-20];
        
        for (let i = 0; i < timeLabels.length; i++) {
            ctx.fillText(`${timeLabels[i].toFixed(2)}s`, xPositions[i], height - 5);
        }
        
        // 범례
        ctx.textAlign = 'left';
        ctx.fillStyle = '#e74c3c';
        ctx.fillText('— 실측 포락선', 10, 15);
        ctx.fillStyle = '#3498db';
        ctx.fillText('--- 이론 곡선', 10, 30);
        
    } catch (error) {
        console.error('포락선 차트 오류:', error);
    }
}

            displaySimpleResults(analysis, channelData, sampleRate) {
    try {
        console.log('결과 표시 중...');

        // 주파수 분석 결과
        const f0 = analysis.dominantFreq;
        document.getElementById('resonantFreq').textContent =
            (Number.isFinite(f0) ? `${f0.toFixed(1)} Hz` : '—');

        const q = analysis.qFactor;
        document.getElementById('qFactor').textContent =
            (Number.isFinite(q) && q > 0) ? q.toFixed(1) : '—';

        document.getElementById('harmonicRatio').textContent =
            `${(analysis.harmonicRatio || 60.0).toFixed(1)}%`;

        // 감쇠 분석 결과 (표시 가드: b<0 & rho<1)
        const ok = Number.isFinite(analysis.decayCoeff) &&
                   analysis.decayCoeff > 0 &&
                   Number.isFinite(analysis.rho) &&
                   analysis.rho < 1;

        if (ok) {
            document.getElementById('decayCoeff').textContent =
                `${analysis.decayCoeff.toFixed(3)} /s`;
            document.getElementById('halfLife').textContent =
                `${analysis.halfLife.toFixed(3)} s`;
            const r2 = Number.isFinite(analysis.rSquared) ? analysis.rSquared : 0;
            document.getElementById('rSquared').textContent = r2.toFixed(3);
        } else {
            document.getElementById('decayCoeff').textContent = '—';
            document.getElementById('halfLife').textContent = '—';
            document.getElementById('rSquared').textContent = '—';
        }

        // 신호 특성 (dB 표기)
        const maxAmpDB = 20 * Math.log10(Math.max(analysis.maxAmplitude, 1e-10));
        const snr = 20 * Math.log10(
            Math.max(analysis.maxAmplitude, 1e-10) / Math.max(analysis.rms, 1e-10)
        );
        document.getElementById('maxAmplitude').textContent = `${maxAmpDB.toFixed(1)} dB`;
        document.getElementById('duration').textContent = `${analysis.duration.toFixed(2)} s`;
        document.getElementById('snr').textContent = `${snr.toFixed(1)} dB`;

        // 포락선 라벨(고정 "10ms" 제거 → 동적 표기)
        const infoEl = document.getElementById('envelopeInfo');
        if (infoEl) {
            const vis = analysis.decayVis;
            if (vis && Number.isFinite(vis.windowSize)) {
                const wSec = vis.windowSize / sampleRate;
                const startSec = (analysis.peakIdx + vis.bestStart * vis.windowSize) / sampleRate;
                const endSec   = (analysis.peakIdx + (vis.bestEnd + 1) * vis.windowSize) / sampleRate;
                const rhoTxt   = Number.isFinite(analysis.rho) ? `, ρ=${analysis.rho.toFixed(3)}` : '';
                infoEl.textContent = `평활≈${wSec.toFixed(3)} s, 창 ${startSec.toFixed(3)}–${endSec.toFixed(3)} s${rhoTxt}`;
            } else {
                infoEl.textContent = '—';
            }
        }

        // 포락선 차트 (최종 창/회귀선 전달)
        this.drawEnvelopeChart(channelData, analysis.peakIdx, sampleRate, analysis.decayVis);

        console.log('결과 표시 완료');
    } catch (error) {
        console.error('결과 표시 오류:', error);
    }
}


            
            drawScrollableWaveform(channelData, sampleRate) {
                try {
                    console.log('스크롤 가능한 파형 차트 그리기...');
                    const canvas = document.getElementById('waveformChart');
                    if (!canvas) return;
                    
                    const ctx = canvas.getContext('2d');
                    
                    // 캔버스 크기 설정
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width || 600;
                    canvas.height = rect.height || 300;
                    
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    // 캔버스 초기화
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#f8f9fa';
                    ctx.fillRect(0, 0, width, height);
                    
                    // 전체 지속시간과 보기 창 계산
                    const totalDuration = channelData.length / sampleRate;
                    const viewDuration = totalDuration / this.zoomLevel;
                    const endTime = Math.min(this.scrollOffset + viewDuration, totalDuration);
                    
                    // 표시할 데이터 범위 계산
                    const startSample = Math.floor(this.scrollOffset * sampleRate);
                    const endSample = Math.floor(endTime * sampleRate);
                    const viewData = channelData.slice(startSample, endSample);
                    
                    if (viewData.length === 0) return;
                    
// === 감쇠 최종창 하이라이트 & 회귀선 ===
if (decayVis && Number.isFinite(decayVis.bestStart) && Number.isFinite(decayVis.bestEnd) && Number.isFinite(decayVis.windowSize)) {
    const width = canvas.width;
    const height = canvas.height;

    const viewStart = this.scrollOffset;
    const viewEnd = endTime;
    const peakTime = peakIdx / sampleRate;
    const wSec = decayVis.windowSize / sampleRate;

    const startAbs = peakTime + (decayVis.bestStart) * wSec;         // 구간 좌측
    const endAbs   = peakTime + (decayVis.bestEnd + 1) * wSec;       // 구간 우측

    // x 좌표 변환 (뷰창 안에서만 표시)
    function toX(sec) {
        const r = (sec - viewStart) / (viewEnd - viewStart + 1e-12);
        return Math.max(0, Math.min(width, r * width));
    }
    const x1 = toX(startAbs);
    const x2 = toX(endAbs);

    if (x2 > 0 && x1 < width && x2 - x1 > 1) {
        // 하이라이트 영역
        const savedFill = ctx.fillStyle, savedAlpha = ctx.globalAlpha;
        ctx.fillStyle = '#f1c40f';
        ctx.globalAlpha = 0.15;
        ctx.fillRect(x1, 0, x2 - x1, height);
        ctx.globalAlpha = savedAlpha;
        ctx.fillStyle = savedFill;

        // 회귀선(y = exp(a + b tRel)), tRel = (절대시간 - peakTime)
        if (Number.isFinite(decayVis.regA) && Number.isFinite(decayVis.regB)) {
            const a = decayVis.regA, b = decayVis.regB;

            // 파형 스케일: -1..+1 → 화면 중앙 기준 0.4배 스케일 (원본과 동일)
            function toY(ampl) {
                const clipped = Math.max(-1, Math.min(1, ampl));
                return height / 2 - (clipped * height * 0.4);
            }

            const savedDash = ctx.getLineDash();
            const savedStroke = ctx.strokeStyle;
            const savedWidth = ctx.lineWidth;

            ctx.setLineDash([5, 3]);
            ctx.strokeStyle = '#e67e22';
            ctx.lineWidth = 2;
            ctx.beginPath();

            const steps = Math.max(16, Math.floor((x2 - x1) / 6));
            for (let i = 0; i <= steps; i++) {
                const xr = x1 + (i / steps) * (x2 - x1);
                const tAbs = viewStart + (xr / width) * (viewEnd - viewStart);
                const tRel = Math.max(0, tAbs - peakTime);
                const envAmp = Math.exp(a + b * tRel); // 포락선 예측 진폭(선형 스케일)
                const y = toY(envAmp);
                if (i === 0) ctx.moveTo(xr, y); else ctx.lineTo(xr, y);
            }
            ctx.stroke();

            ctx.setLineDash(savedDash);
            ctx.strokeStyle = savedStroke;
            ctx.lineWidth = savedWidth;
        }
    }
}
// === 오버레이 끝 ===


                    // 최대 진폭 찾기 (정규화용)
                    let maxAmplitude = 0;
                    for (let i = 0; i < viewData.length; i++) {
                        maxAmplitude = Math.max(maxAmplitude, Math.abs(viewData[i]));
                    }
                    
                   // Y축 고정 범위 (-1~+1) 사용
// amplificationFactor 계산 삭제
                    
                    // 데이터 다운샘플링 (성능 최적화)
                    const maxPoints = Math.min(2000, viewData.length);
                    const step = Math.max(1, Math.floor(viewData.length / maxPoints));
                    
                    // 파형 그리기
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    let pointsDrawn = 0;
                    for (let i = 0; i < viewData.length; i += step) {
                       const sample = viewData[i] || 0;
const clippedSample = Math.max(-1, Math.min(1, sample));
const x = (pointsDrawn / maxPoints) * width;
const y = height / 2 - (clippedSample * height * 0.4);
                        
                        if (pointsDrawn === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        pointsDrawn++;
                        
                        if (pointsDrawn >= maxPoints) break;
                    }
                    
                    ctx.stroke();
                    
                    // 중앙선과 격자
                    ctx.strokeStyle = '#95a5a6';  // 더 진한 회색
ctx.lineWidth = 1.5;
                    
                    // 중앙선
                    ctx.beginPath();
                    ctx.moveTo(0, height / 2);
                    ctx.lineTo(width, height / 2);
                    ctx.stroke();
                    

                    // 격자선
                    ctx.setLineDash([3, 3]);
                    const levels = [0.2, 0.4, 0.6, 0.8];
                    
                    for (const level of levels) {
                        ctx.beginPath();
                        ctx.moveTo(0, height / 2 - (height * level * 0.4));
                        ctx.lineTo(width, height / 2 - (height * level * 0.4));
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(0, height / 2 + (height * level * 0.4));
                        ctx.lineTo(width, height / 2 + (height * level * 0.4));
                        ctx.stroke();
                    }
                    
                    ctx.setLineDash([]);
                    
                 // 시간축 라벨 (격자와 정확히 일치)
ctx.fillStyle = '#2c3e50';
ctx.font = '12px Arial';
ctx.textAlign = 'center';

const labelMargin = 20;

// 화면에 표시되는 시간 구간
const currentViewDuration = totalDuration / this.zoomLevel;
const startTime = this.scrollOffset;
const viewEndTime = this.scrollOffset + currentViewDuration;  // 이름 변경

// 보기 좋은 눈금 간격 선택
const roughStep = currentViewDuration / 8;   // 대략 8칸 정도 보이게
const pow10 = Math.pow(10, Math.floor(Math.log10(roughStep)));
let tickStep = pow10;   // step → tickStep 으로 변경
if (roughStep / tickStep > 5) tickStep *= 5;
else if (roughStep / tickStep > 2) tickStep *= 2;

// 소수점 자릿수 결정
const decimals = tickStep < 0.001 ? 6 :
                 tickStep < 0.01  ? 4 :
                 tickStep < 0.1   ? 3 :
                 tickStep < 1     ? 2 :
                 tickStep < 10    ? 1 : 0;

// tickStep 배수로 스냅
let tick = Math.ceil(startTime / tickStep) * tickStep;
ctx.textAlign = 'center';
ctx.fillStyle = '#2c3e50';
ctx.font = '12px Arial';

// 라벨 그리기
while (tick <= viewEndTime) {
    const x = ((tick - startTime) / currentViewDuration) * width;

 // 세로선 추가
    ctx.beginPath();
    ctx.moveTo(x, 20);
    ctx.lineTo(x, height - 40);
    ctx.strokeStyle = '#bdc3c7';
    ctx.setLineDash([2, 4]);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillText(`${parseFloat(tick.toFixed(decimals))}s`, x, height - 10);

    tick += tickStep;
}
                    
                    // 진폭 라벨 (고정 범위)
ctx.textAlign = 'right';
ctx.fillText('+1.0', width - 15, 25);
ctx.fillText('0.0', width - 15, height / 2 + 5);
ctx.fillText('-1.0', width - 15, height - 25);
                    
                    // 상태 정보 표시
                    ctx.textAlign = 'left';
                    ctx.font = '10px Arial';
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillText(`줌: ${this.zoomLevel.toFixed(1)}x`, 10, 20);
                    
                    // 스크롤바 표시
                    this.drawScrollbar(ctx, width, height, totalDuration, viewDuration);
                    
                    // 조작 안내
                    ctx.fillStyle = '#95a5a6';
                    ctx.font = '9px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText('드래그: 스크롤 | 휠: 줌 | 더블클릭: 리셋', width - 10, height - 25);
                    
                    console.log('스크롤 가능한 파형 차트 완료');
                    
                } catch (error) {
                    console.error('스크롤 파형 차트 오류:', error);
                }
            }
            
            drawScrollbar(ctx, width, height, totalDuration, viewDuration) {
                // 스크롤바 배경
                const scrollbarHeight = 8;
                const scrollbarY = height - 40;
                
                ctx.fillStyle = '#ecf0f1';
                ctx.fillRect(0, scrollbarY, width, scrollbarHeight);
                
                // 스크롤바 핸들
                const handleWidth = (viewDuration / totalDuration) * width;
                const handleX = (this.scrollOffset / totalDuration) * width;
                
                ctx.fillStyle = '#3498db';
                ctx.fillRect(handleX, scrollbarY, handleWidth, scrollbarHeight);
                
                // 스크롤바 테두리
                ctx.strokeStyle = '#bdc3c7';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, scrollbarY, width, scrollbarHeight);
            }
            
            drawRealSpectrum(spectrum, freqBins, sampleRate) {
                try {
                    console.log('실제 FFT 스펙트럼 차트 그리기...');
                    const canvas = document.getElementById('spectrumChart');
                    if (!canvas) return;
                    
                    const ctx = canvas.getContext('2d');
                    
                    // 캔버스 크기 설정
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width || 600;
                    canvas.height = rect.height || 300;
                    
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    // 캔버스 초기화
                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#f8f9fa';
                    ctx.fillRect(0, 0, width, height);
                    
                    if (spectrum.length === 0) return;
                    
                    // 표시할 주파수 범위 (0 ~ 5000Hz)
                    const maxFreq = Math.min(5000, sampleRate / 2);
                    const displaySpectrum = [];
                    const displayFreqs = [];
                    
                    // 주파수 빈이 있으면 사용, 없으면 계산
                    if (freqBins.length > 0) {
                        for (let i = 0; i < spectrum.length && i < freqBins.length; i++) {
                            if (freqBins[i] <= maxFreq) {
                                displaySpectrum.push(spectrum[i]);
                                displayFreqs.push(freqBins[i]);
                            }
                        }
                    } else {
                        // 폴백: 주파수 빈 계산
                        for (let i = 0; i < spectrum.length; i++) {
                            const freq = (i / spectrum.length) * (sampleRate / 2);
                            if (freq <= maxFreq) {
                                displaySpectrum.push(spectrum[i]);
                                displayFreqs.push(freq);
                            }
                        }
                    }
                    
                    console.log('스펙트럼 표시 정보:', {
                        originalLength: spectrum.length,
                        displayLength: displaySpectrum.length,
                        maxFreq: maxFreq,
                        freqRange: displayFreqs.length > 0 ? 
                            `${displayFreqs[0].toFixed(1)} - ${displayFreqs[displayFreqs.length-1].toFixed(1)} Hz` : 'N/A'
                    });
                    
                    if (displaySpectrum.length === 0) return;
                    
                    // 로그 스케일 주파수축 설정
                    const useLogScale = true;
                    const minFreq = Math.max(20, displayFreqs[0] || 20); // 최소 20Hz
                    
                    // 막대 그래프로 그리기
                    const barWidth = width / displaySpectrum.length;
                    
                   for (let i = 0; i < displaySpectrum.length; i++) {
    const magnitude = displaySpectrum[i];
    const magnitudeDB = 20 * Math.log10(Math.max(magnitude, 1e-6)); // dB 변환
    const normalizedDB = Math.max(0, (magnitudeDB + 60) / 60); // -60dB ~ 0dB를 0~1로 정규화
    const freq = displayFreqs[i];
                        
                        let x;
                        if (useLogScale && freq > 0) {
                            // 로그 스케일
                            const logMin = Math.log10(minFreq);
                            const logMax = Math.log10(maxFreq);
                            const logFreq = Math.log10(Math.max(freq, minFreq));
                            x = ((logFreq - logMin) / (logMax - logMin)) * width;
                        } else {
                            // 선형 스케일
                            x = (freq / maxFreq) * width;
                        }
                        
                       const barHeight = normalizedDB * (height - 60); // dB 기준 높이
                        const y = height - barHeight - 30;
                        
                        // 주파수에 따른 색상 (파란색 -> 빨간색)
                        const hue = 240 - (freq / maxFreq) * 180; // 240(파란색) -> 60(노란색) -> 0(빨간색)
                        const saturation = 70;
                        const lightness = 50;
                        const alpha = 0.7 + normalizedDB * 0.3; // dB 기준 투명도
                        
                        ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                        
                        // 막대 너비 계산 (로그 스케일 고려)
                        let nextX = width;
                        if (i < displaySpectrum.length - 1) {
                            const nextFreq = displayFreqs[i + 1];
                            if (useLogScale && nextFreq > 0) {
                                const logMin = Math.log10(minFreq);
                                const logMax = Math.log10(maxFreq);
                                const logNextFreq = Math.log10(Math.max(nextFreq, minFreq));
                                nextX = ((logNextFreq - logMin) / (logMax - logMin)) * width;
                            } else {
                                nextX = (nextFreq / maxFreq) * width;
                            }
                        }
                        
                        const actualBarWidth = Math.max(1, nextX - x);
                        ctx.fillRect(x, y, actualBarWidth, barHeight);
                    }
                    
                    // 주파수 축 라벨 (로그 스케일)
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'center';
                    
                    const freqLabels = useLogScale ? 
                        [20, 50, 100, 200, 500, 1000, 2000, 5000] :
                        [0, maxFreq/4, maxFreq/2, 3*maxFreq/4, maxFreq];
                    
                    for (const freq of freqLabels) {
                        if (freq <= maxFreq && freq >= minFreq) {
                            let x;
                            if (useLogScale) {
                                const logMin = Math.log10(minFreq);
                                const logMax = Math.log10(maxFreq);
                                const logFreq = Math.log10(freq);
                                x = ((logFreq - logMin) / (logMax - logMin)) * width;
                            } else {
                                x = (freq / maxFreq) * width;
                            }
                            
                            let label;
                            if (freq >= 1000) {
                                label = `${(freq/1000).toFixed(freq % 1000 === 0 ? 0 : 1)}k`;
                            } else {
                                label = `${freq}`;
                            }
                            
                            ctx.fillText(label, x, height - 5);
                            
                            // 격자선
                            ctx.strokeStyle = '#e0e0e0';
                            ctx.lineWidth = 1;
                            ctx.setLineDash([2, 2]);
                            ctx.beginPath();
                            ctx.moveTo(x, height - 30);
                            ctx.lineTo(x, 30);
                            ctx.stroke();
                            ctx.setLineDash([]);

                        }
                    }
                    
                   // dB 축 라벨 (더 정밀하게)
ctx.textAlign = 'right';
const dbLevels = [0, -10, -20, -30, -40, -50, -60];
for (const db of dbLevels) {
    const y = 30 + ((0 - db) / 60) * (height - 60);
    if (y >= 30 && y <= height - 30) {
        ctx.fillText(`${db}dB`, width - 5, y + 4);
        
        // 격자선 추가
        if (db !== 0) {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            ctx.setLineDash([1, 2]);
            ctx.beginPath();
            ctx.moveTo(20, y);
            ctx.lineTo(width - 40, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
}
                    
                    // 제목과 정보
                    ctx.textAlign = 'left';
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#2c3e50';
                    ctx.fillText('주파수 스펙트럼 (실제 FFT)', 10, 20);
                    
                    ctx.font = '10px Arial';
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillText(`FFT 크기: ${spectrum.length * 2} | ${useLogScale ? '로그' : '선형'} 스케일`, 10, height - 10);
                    
                    // 주요 피크 표시
                    this.markSpectralPeaks(ctx, displaySpectrum, displayFreqs, width, height, useLogScale, minFreq, maxFreq);
                    
                    console.log('실제 FFT 스펙트럼 차트 완료');
                    
                } catch (error) {
                    console.error('실제 스펙트럼 차트 오류:', error);
                }
            }
            
            markSpectralPeaks(ctx, spectrum, freqs, width, height, useLogScale, minFreq, maxFreq) {
                try {
                    // 피크 찾기 (임계값 이상)
                    const threshold = Math.max(...spectrum) * 0.3; // 30% 임계값
                    const peaks = [];
                    
                    for (let i = 1; i < spectrum.length - 1; i++) {
                        if (spectrum[i] > threshold && 
                            spectrum[i] > spectrum[i-1] && 
                            spectrum[i] > spectrum[i+1]) {
                            peaks.push({ freq: freqs[i], magnitude: spectrum[i], index: i });
                        }
                    }
                    
                    // 상위 3개 피크만 표시
                    peaks.sort((a, b) => b.magnitude - a.magnitude);
                    const topPeaks = peaks.slice(0, 3);
                    
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '9px Arial';
                    ctx.textAlign = 'center';
                    
                    for (const peak of topPeaks) {
                        let x;
                        if (useLogScale && peak.freq > 0) {
                            const logMin = Math.log10(minFreq);
                            const logMax = Math.log10(maxFreq);
                            const logFreq = Math.log10(Math.max(peak.freq, minFreq));
                            x = ((logFreq - logMin) / (logMax - logMin)) * width;
                        } else {
                            x = (peak.freq / maxFreq) * width;
                        }
                        
                        const y = height - peak.magnitude * (height - 60) - 30;
                        
                        // 피크 마커
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // 주파수 라벨
                        const freqLabel = peak.freq >= 1000 ? 
                            `${(peak.freq/1000).toFixed(1)}kHz` : 
                            `${Math.round(peak.freq)}Hz`;
                        
                        ctx.fillText(freqLabel, x, y - 8);
                    }
                    
                } catch (error) {
                    console.error('피크 표시 오류:', error);
                }
            }
            
            // 실시간 녹음 기능 (원본 그대로 복원)
          async startRealTimeRecording() {
    // 중복 실행 방지
    if (this.isCountingDown || this.isRecording) return;
    
    // 즉시 마이크 권한 요청
    this.updateStatus('마이크 권한을 요청하고 있습니다...', 'analyzing');
    
    try {
        // 마이크 권한부터 먼저 확인
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('이 브라우저는 마이크 접근을 지원하지 않습니다.');
        }
        
        const constraints = {
            audio: {
                sampleRate: 44100,
                channelCount: 1,
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: false
            }
        };
        
       // 마이크 권한 테스트 및 스트림 준비
const testStream = await navigator.mediaDevices.getUserMedia(constraints);
this.preparedStream = testStream; // 스트림을 저장해서 재사용
        
        this.updateStatus('마이크 권한이 승인되었습니다! 10초 후 녹음을 시작합니다.', 'analyzing');
        
        // 권한 승인 후 카운트다운 시작
        this.isCountingDown = true;
        let countdown = 10;
        const recordBtn = document.getElementById('recordBtn');
        
        this.countdownInterval = setInterval(() => {
            recordBtn.textContent = `🔴 ${countdown}초 후 시작`;
            this.updateStatus(`${countdown}초 후 녹음을 시작합니다.`, 'analyzing');
            countdown--;
            
            if (countdown < 0) {
                clearInterval(this.countdownInterval);
                this.countdownInterval = null;
                this.isCountingDown = false;
                this.startActualRecording();
            }
        }, 1000);
        
    } catch (error) {
        console.error('마이크 권한 요청 실패:', error);
        
        let errorMessage = '마이크 권한 요청에 실패했습니다. ';
        if (error.name === 'NotAllowedError') {
            errorMessage = '마이크 권한이 거부되었습니다. 브라우저 설정에서 마이크 권한을 허용해주세요.';
        } else if (error.name === 'NotFoundError') {
            errorMessage = '마이크를 찾을 수 없습니다. 기기에 마이크가 연결되어 있는지 확인해주세요.';
        } else if (error.name === 'NotSupportedError') {
            errorMessage = '이 브라우저에서는 녹음을 지원하지 않습니다. Chrome 브라우저를 사용해보세요.';
        } else {
            errorMessage += error.message;
        }
        
        this.updateStatus(errorMessage, 'error');
    }
}

async playBeepSound() {
    try {
        // 이미 생성된 AudioContext 사용
        const audioContext = this.audioContext;
        
        // 비프음 생성 (800Hz, 0.2초)
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // 주파수와 볼륨 설정
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // 800Hz
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); // 볼륨 30%
        
        // 페이드 아웃 효과
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
        
        // 비프음 재생
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.2);
        
        // 비프음이 끝날 때까지 대기
        await new Promise(resolve => setTimeout(resolve, 250));
        
    } catch (error) {
        console.log('비프음 재생 실패:', error);
        // 에러가 나도 녹음은 계속 진행
    }
}

async startActualRecording() {
     try {
      
                            
                    // 갤럭시 최적화: AudioContext 먼저 생성 및 활성화
                    console.log('AudioContext 생성 및 활성화...');
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                        console.log('AudioContext 활성화 완료:', this.audioContext.state);
                    }
                    
                    // 갤럭시(Android Chrome) 최적화 오디오 설정
                    const constraints = {
                        audio: {
                            sampleRate: 44100,
                            channelCount: 1,
                            echoCancellation: true,     // 갤럭시에서 중요
                            noiseSuppression: true,     // 갤럭시에서 중요
                            autoGainControl: false
                        }
                    };
                    
                   console.log('저장된 마이크 스트림 사용...');
const stream = this.preparedStream; // 이미 준비된 스트림 사용
console.log('마이크 스트림 사용 준비 완료');
                    
                    // 갤럭시용 MIME 타입 체크 (우선순위: webm > mp4 > wav)
                    let options = {};
                    let mimeType = 'audio/webm;codecs=opus';  // 갤럭시 선호 포맷
                    
                    if (MediaRecorder.isTypeSupported(mimeType)) {
                        options.mimeType = mimeType;
                        console.log('MIME 타입 설정: audio/webm;codecs=opus');
                    } else if (MediaRecorder.isTypeSupported('audio/webm')) {
                        options.mimeType = 'audio/webm';
                        console.log('MIME 타입 설정: audio/webm');
                    } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                        options.mimeType = 'audio/mp4';
                        console.log('MIME 타입 설정: audio/mp4');
                    } else if (MediaRecorder.isTypeSupported('audio/wav')) {
                        options.mimeType = 'audio/wav';
                        console.log('MIME 타입 설정: audio/wav');
                    } else {
                        console.log('기본 MIME 타입 사용');
                    }
                    
                    console.log('MediaRecorder 설정:', options);
                    
                    this.mediaRecorder = new MediaRecorder(stream, options);
                    this.recordedChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        console.log('데이터 수신:', event.data.size, 'bytes');
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = async () => {
                        console.log('녹음 중지, 총 청크:', this.recordedChunks.length);
                        const finalMimeType = this.mediaRecorder.mimeType || options.mimeType || 'audio/wav';
                        const audioBlob = new Blob(this.recordedChunks, { type: finalMimeType });
                        console.log('생성된 Blob:', audioBlob.size, 'bytes, type:', audioBlob.type);
                        await this.processRecordedAudio(audioBlob);
                    };
                    
                    this.mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder 오류:', event.error);
                        this.updateStatus(`녹음 중 오류: ${event.error.message}`, 'error');
                    };
                    
                    this.currentStream = stream;
                    this.isRecording = true;
                    
// 녹음 시작 직전에 비프음 재생
await this.playBeepSound();

                    // 갤럭시 최적화: 더 긴 간격으로 데이터 수집 (안정성 향상)
                    this.mediaRecorder.start(2000); // 1초 → 2초로 증가
                    console.log('녹음 시작 (2초 간격)');
                    
                    const recordBtn = document.getElementById('recordBtn');
                    recordBtn.textContent = '🔴 녹음 중...';
                    recordBtn.classList.add('recording');
                    
                    this.updateStatus('실시간 녹음 중입니다. 재질을 타격하고 최소 3초 이상 녹음해주세요.', 'analyzing');
                    
                    // 자동 중지 타이머 (10초 후)
                    this.autoStopTimer = setTimeout(() => {
                        if (this.isRecording) {
                            console.log('자동 중지 (10초 경과)');
                            this.stopRealTimeRecording();
                        }
                    }, 10000);
                    
                } catch (error) {
                    console.error('실시간 녹음 오류:', error);
                    
                    // 갤럭시용 상세 에러 메시지
                    let errorMessage = '실시간 녹음에 실패했습니다. ';
                    if (error.name === 'NotAllowedError') {
                        errorMessage = '마이크 권한이 거부되었습니다. 브라우저 설정에서 마이크 권한을 허용해주세요.';
                    } else if (error.name === 'NotFoundError') {
                        errorMessage = '마이크를 찾을 수 없습니다. 기기에 마이크가 연결되어 있는지 확인해주세요.';
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage = '이 브라우저에서는 녹음을 지원하지 않습니다. Chrome 브라우저를 사용해보세요.';
                    } else {
                        errorMessage += error.message;
                    }
                    
                    this.updateStatus(errorMessage, 'error');
                }
            }
            
            stopRealTimeRecording() {
// 카운트다운 중이면 취소
if (this.isCountingDown) {
    clearInterval(this.countdownInterval);
    this.countdownInterval = null;
    this.isCountingDown = false;
    const recordBtn = document.getElementById('recordBtn');
    recordBtn.textContent = '🎤 실시간 녹음';
    this.updateStatus('카운트다운이 취소되었습니다.', 'ready');
    return;
}

                if (this.isRecording && this.mediaRecorder) {
                    console.log('녹음 중지 요청');
                    
                    // 자동 중지 타이머 해제
                    if (this.autoStopTimer) {
                        clearTimeout(this.autoStopTimer);
                        this.autoStopTimer = null;
                    }
                    
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    
                    if (this.currentStream) {
                        this.currentStream.getTracks().forEach(track => {
                            track.stop();
                            console.log('트랙 중지:', track.kind);
                        });
                        this.currentStream = null;
                    }
                    
                    if (this.audioContext && this.audioContext.state !== 'closed') {
                        this.audioContext.close();
                        this.audioContext = null;
                    }
                    
                    const recordBtn = document.getElementById('recordBtn');
                    recordBtn.textContent = '🎤 실시간 녹음';
                    recordBtn.classList.remove('recording');
                    
                    this.updateStatus('녹음을 중지하고 분석을 시작합니다...', 'analyzing');
                    console.log('녹음 중지 완료');
                }
            }
            
            async processRecordedAudio(audioBlob) {
                try {
                    console.log('녹음된 Blob 정보:', {
                        size: audioBlob.size,
                        type: audioBlob.type
                    });
                    
                    // 1단계: Blob 크기 확인
                    if (audioBlob.size < 1000) {
                        throw new Error('녹음 데이터가 너무 작습니다. 더 오래 녹음해주세요.');
                    }
                    
                    // 2단계: ArrayBuffer 변환
                    console.log('ArrayBuffer 변환 중...');
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    console.log('ArrayBuffer 크기:', arrayBuffer.byteLength);
                    
                    // 3단계: 오디오 컨텍스트 생성
                    console.log('AudioContext 생성 중...');
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // 4단계: 오디오 디코딩 (더 안전한 방법)
                    console.log('오디오 디코딩 중...');
                    let audioBuffer;
                    
                    try {
                        audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        console.log('디코딩 성공:', {
                            duration: audioBuffer.duration,
                            sampleRate: audioBuffer.sampleRate,
                            channels: audioBuffer.numberOfChannels
                        });
                    } catch (decodeError) {
                        console.error('디코딩 오류:', decodeError);
                        
                        // 폴백: WAV 형식으로 재시도
                        console.log('WAV 형식으로 재시도...');
                        const wavBlob = await this.convertToWav(audioBlob);
                        const wavArrayBuffer = await wavBlob.arrayBuffer();
                        audioBuffer = await audioContext.decodeAudioData(wavArrayBuffer);
                    }
                    
                    // 5단계: 오디오 버퍼 유효성 확인
                    if (!audioBuffer || audioBuffer.duration < 0.1) {
                        throw new Error('유효하지 않은 오디오 데이터입니다.');
                    }
                    
                    // 6단계: 분석 실행
                    console.log('분석 시작...');
                    await this.analyzeAudioBuffer(audioBuffer);
                    
                } catch (error) {
                    console.error('녹음 데이터 처리 오류:', error);
                    
                    let errorMessage = '녹음 데이터 처리 중 오류가 발생했습니다: ';
                    
                    if (error.message.includes('너무 작습니다')) {
                        errorMessage = '녹음 시간이 너무 짧습니다. 3초 이상 녹음해주세요.';
                    } else if (error.message.includes('디코딩')) {
                        errorMessage = '오디오 형식을 인식할 수 없습니다. 다른 브라우저를 시도해보세요.';
                    } else if (error.message.includes('유효하지 않은')) {
                        errorMessage = '녹음된 오디오가 유효하지 않습니다. 다시 녹음해주세요.';
                    } else {
                        errorMessage += error.message;
                    }
                    
                    this.updateStatus(errorMessage, 'error');
                    
                    // 디버그 정보 표시
                    this.showDebugInfo(error, audioBlob);
                }
            }
            
            async convertToWav(audioBlob) {
                // 간단한 WAV 변환 (실제로는 더 정교한 변환 필요)
                return audioBlob; // 임시 구현
            }
            
            showDebugInfo(error, audioBlob) {
                const debugInfo = `
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 10px; padding: 15px; margin: 15px 0; font-size: 0.9em;">
                        <h4 style="color: #856404; margin-bottom: 10px;">🔧 디버그 정보</h4>
                        <p><strong>오류:</strong> ${error.message}</p>
                        <p><strong>Blob 크기:</strong> ${audioBlob.size} bytes</p>
                        <p><strong>Blob 타입:</strong> ${audioBlob.type}</p>
                        <p><strong>브라우저:</strong> ${navigator.userAgent}</p>
                        <p style="margin-top: 10px; color: #856404;">
                            <strong>해결 방법:</strong><br>
                            1. 더 오래 녹음하기 (3초 이상)<br>
                            2. 다른 브라우저 시도<br>
                            3. 파일 업로드 방식 사용
                        </p>
                    </div>
                `;
                
                const container = document.querySelector('.container');
                const existingDebug = container.querySelector('.debug-info');
                if (existingDebug) {
                    existingDebug.remove();
                }
                
                const debugDiv = document.createElement('div');
                debugDiv.className = 'debug-info';
                debugDiv.innerHTML = debugInfo;
                container.appendChild(debugDiv);
            }
            
            clearAll() {
                document.getElementById('resultsSection').classList.add('hidden');
                document.getElementById('fileInput').value = '';
                this.updateStatus('오디오 파일을 업로드하거나 실시간 녹음을 시작하세요.', 'ready');
                
                // 파형 데이터 초기화
                this.waveformData = null;
                this.waveformSampleRate = 44100;
                this.scrollOffset = 0;
                this.zoomLevel = 1;
                
        
                
                // 값들 초기화
                const elements = ['resonantFreq', 'qFactor', 'harmonicRatio', 'decayCoeff', 'halfLife', 'rSquared', 'maxAmplitude', 'duration', 'snr', 'freqMatch', 'decayPattern', 'totalScore'];
                elements.forEach(id => {
                     document.getElementById(id).textContent = '--';
                });
            }
            
            updateStatus(message, type) {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status status-${type}`;
            }
        }
        
        // 앱 초기화
        document.addEventListener('DOMContentLoaded', () => {
            new OfflineMaterialAnalyzer();
        });
    </script>
</body>
</html>